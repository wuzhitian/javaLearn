[TOC]

## JAVA基础语法

### 1 关键字

### 2 标识符

### 3 注释

### 4 进制转换

* 二进制转十六进制（四位二进制位表示一位十六进制）；
* 二进制转八进制（三位二进制表示一位八进制）；
* 负数的二进制表现形式
	6 ---> 110
	-6: 6的二进制取反+1（取反：1变成0，0变成1）

### 5 常量与变量

整数：

* byte: 8位二进制；
* short: 16位二进制；
* int: 32位二进制；
* long: 64位二进制

Java默认浮点数类型为double
Java默认整数类型为int
Java自动类型提升，小范围向大范围转

-1%5 = -1;
-2%5 = -2;
2%-5 = 2;
负数取模只看被模数（左边）


char c = '我';	//没问题，一个汉字两个字节，char类型也是两个字节;

	n = n + m; m = n - m; n = n - m;

	a = a ^ b; b = a ^ b; a = a ^ b;


```java
	class Demo
	{
		public static void main(String[] args)
		{
			int x = 56;

			int a = x & 15;

			int b = x >>= 4 & 15;

			int c = x >>= 4 & 15;

			System.out.println(a+", "+b+", "+c);
		}
	}
```

## 函数重载

重载的概念: 在同一个类中，允许存在一个以上的同名函数，只要它们的参数`个数`或者参数`类型`不同即可；
重载特点：与`返回值` `无关`，只看参数列表；

## 数组

	int[] arr = new int[2];
	int arr[] = new int[2];

	int[] arr = new int[]{1, 2, 3};
	int arr[] = new int[]{1 ,2, 3};

	int[] arr = {1, 2, 3};

//ArrayIndexOutOfBoundsException: 操作数组时，访问到了数组中不存在的脚标
//NullPointerException: 空指针异常：当引用没有任何指向值为null的情况，该引用还在用于操作实体

### 排序

1.选择排序

```java
class selectSort
{
	public static void main(String[] args)
	{
		int[] arr = {21, 12, 43, 23, 44, 54, 22};
		printArr(arr);
		selectSort(arr);	//数组 引用类型;
		printArr(arr);
	}
	public static int[] selectSort(int[] arr)
	{
		for(int x = 0; x < arr.length-1; x++)	//x < arr.length -1;
		{
			for(int y = x+1; y < arr.length; y++) //y = x+1
			{
				if(arr[x] > arr[y])
				{
					// arr[x] = arr[x] ^ arr[y];
					// arr[y] = arr[x] ^ arr[y];
					// arr[x] = arr[x] ^ arr[y];
					
					// arr[x] = arr[x] + arr[y];
					// arr[y] = arr[x] - arr[y];
					// arr[x] = arr[x] - arr[y];

					int temp = arr[x];
					arr[x] = arr[y];
					arr[y] = temp;
				}
			}
		}
		return arr;
	}
	public static void printArr(int[] arr)
	{
		System.out.print("[");
		for(int x = 0; x < arr.length; x++)
		{
			if(x != arr.length - 1)
			{
				System.out.print(arr[x]+" ,");
			}
			else
			{
				System.out.println(arr[x]+"]");
			}
		}
	}
}
```

```java
class bubbleSort
{
	public static void main(String[] args)
	{
		int[] arrA = {122, 12, 321, 442, 112, 423};
		printArr(arrA);
		bubbleSort(arrA);
		printArr(arrA);
	}
	public static int[] bubbleSort(int[] arr)
	{
		//for(int x = 0; x < arr.length - 1; x++)
		//{
		//	for(int y = 0; y < arr.length - x - 1; y++)
		//	{
		//		if(arr[y] < arr[y+1])
		//		{
		//			swap(arr, y, y+1);
		//		}
		//	}
		//}

		for(int x = 0; x < arr.length - 1; x++)
		{
			for(int y = arr.length - 1; y > x; y--)
			{
				if(arr[y] > arr[y - 1])
				{
					swap(arr, y, y-1);
				}
			}

		}

		return arr;
	}
	public static void printArr(int[] arr)
	{
		System.out.print("[");
		for(int x = 0; x < arr.length; x++)
		{
			if(x != arr.length-1)
			{
				System.out.print(arr[x]+", ");
			}
			else
			{
				System.out.println(arr[x]+"]");
			}
		}
	}
	public static void swap(int[] arr, int a, int b)
	{
		arr[a] = arr[a] ^ arr[b];
		arr[b] = arr[a] ^ arr[b];
		arr[a] = arr[a] ^ arr[b];
	}

}
```

```java
class getIndex
{
	public static void main(String[] args)
	{
		int[] arr = {2, 4, 1, 6, 7, 8, 5, 0};
		System.out.println(getIndex(arr, 1));		//2

		int[] arrA = {2, 3, 5, 6, 7, 8, 20};
		System.out.println(halfSearch(arrA, 20));	//6
		System.out.println(halfSearch_2(arrA, 8));	//5

		System.out.println(getIndex_2(arrA, 4));

		System.out.println((double)(13/3));	//4.0;
		System.out.println((double)13/3);	//4.33333333333333333
		System.out.println((double)13/(double)3);	//4.33333333333333333
	}
	public static int getIndex_2(int[] arr, int key)	
	{
		int min = 0, max = arr.length-1, mid;
		while(max >= min)
		{
			mid = (max+min)>>1;
			// System.out.println(mid);
			if(key > arr[mid])
			{
				min = mid+1;
			}
			else if(key < arr[mid])
			{
				max = mid-1;
			}
			else
			{
				return mid;
			}
			mid = (max + min)>>1;
		}
		return min;
	}
	public static int getIndex(int[] arr, int key)
	{
		for(int x = 0; x < arr.length; x++)
		{
			if(arr[x] == key)
			{
				return x;
			}
		}
		return -1;
	}
	public static int halfSearch_2(int[] arr, int key)
	{
		int min = 0, max = arr.length - 1, mid=(max+min)/2;
		while(arr[mid] != key)
		{
			if(key > arr[mid])
			{
				min = mid +1;
			}
			else
			{
				max = mid -1;
			}
			if(min > max)
			{
				return -1;
			}
			mid = (max + min)>>1;
		}
		return mid;
	}
	public static int halfSearch(int[] arr, int key)
	{
		int min=0, max = arr.length-1, mid;
		while(min <= max)
		{
			mid = (max + min) >> 1;
			if(key > arr[mid])
			{
				min = mid + 1;
			}
			else if(key < arr[mid])
			{
				max = mid - 1;
			}
			else{
				return mid;
			}
		}
		return -1;
	}
} 
```

### 进制转换

```java
class radix_C
{
	public static void main(String[] args)
	{
		toBin(22);
		toHex(878);
	}
	public static void toBin(int num)
	{
		trans(num, 2);
	}
	public static void toHex(int num)
	{
		trans(num, 16);
	}
	
	public static void trans(int num, int base)
	{
		char[] chs = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E', 'F'};
		char[] arr = new char[32];
		int pos = arr.length;

		int offset = 0, tempBase = base;
		while(tempBase > 1)
		{
			offset++;
			tempBase >>= 1; 
		}

		while(num != 0)
		{
			int temp = num & (base - 1);

			arr[--pos] = chs[temp];

			num >>>= offset;
		}
		for(int x = pos; x < arr.length; x++)
		{
			System.out.print(arr[x]);
		}
		System.out.println("");
	}
}
```

### 二维数组

```java
	int[][] arrA = new int[2][3];

	int[][] arrB = new int[3][];

	int[][] arrC = {{1, 2}, {3, 4}, {5, 6}};

	int[] arrD[] = new int[3][];

```



## 面向对象

### 1.1 名词提炼法

```java
/*
人开门：名词提炼法
人
{
	开门(门)
	{
		门.开()
	}
}
门
{
	开()
	{
		操作门轴
	}
}

 */
```

### 1.2 类和对象的关系
现实生活中的对象：张三，李四。
想要描述：提取对象中共性内容。对具体的抽象。
描述时：这些对象的共性有：姓名，年龄，性别，升高。

映射到Java中，描述就是class定义的类。
具体对象就是对应Java在堆内存中用new建立的实体。

类：对现实生活中事物的描述。
对象：就是这类事物，实实在在存在个体


### 面向对象的三个特征： 封装(Encapsulation)，继承，多态

简介：

需求：描述汽车（颜色，轮胎数）。描述事物其实就是描述事物的属性和行为。
属性对应是类中的变量，行为对应的是类中的函数（方法）
其实定义类，就是在描述事物，就是在定义属性的行为。属性和行为共同成为类中的成员（成员变量和成员方法）。

```java

class Car
{
	//描述颜色
	String color = "red";	//成员变量
	//描述轮胎数
	int num = 4;			//成员变量
	//运行行为
	void run()
	{
		System.out.println(color+"...."+num);
	}
}

class CarA
{
	public static void main(String[] args)
	{
		//生产凄恻。在Java中通过new操作符来完成
		//其实就是在堆内存产生一个实体。
		Car c1 = new Car();	//c1就是一个类类型变量。记住：类类型变量指向对象。

		c1.run();	//red....4
		//需求：将已有车的颜色改成蓝色。指挥该对象做事情。
		//在Java中指挥方式是： 对象.对象成员
		c2.num = 5;

		c1.run();	//red....5

		Car c2 = c1;

		c2.color = "green";	//green....4

		c1.run();

		// c2.num = "AA";	//不兼容的类型: String无法转换为int

		c1.run();
	}
}

```

匿名函数

```java
class Car
{
	String color = "red";

	int num = 4;

	void run()
	{
		System.out.println(color+"....."+num);
	}
}
class CarD
{
	public static void main(String[] args)
	{
		Car c1 = show(new Car());	//匿名函数
		c1.run();	//yellow.....10
	}
	public static Car show(Car c)
	{
		c.color = "yellow";
		c.num = 10;
		return c;
	}
}
```
#### 2.1封装 (Encapsulation)

封装：是指隐藏对象的属性和实现细节，仅对外提供公共访问方式。

好处：
1.将变化隔离；
2.便于使用；
3.提高重用性；
4.提高安全性。

封装原则：
1.将不需要对外提供的内容都隐藏起来；
2.把属性都隐藏起来，提供公共方法对其访问。

##### 2.1.1 修饰符 private
private：私有，权限修饰符。用于修饰类中的成员（成员变量，成员函数）。私有只在本类中有效。
注意：私有仅仅是封装的一种表现形式。

(05/PersonA.java)

```java
class Person
{
	private int age;
	void speak()
	{
		System.out.println("age: "+age);
	}

	public void setAge(int personAge)
	{
		if(personAge > 0 && personAge < 130)
		{
			age = personAge;
			speak();
		}
		else
		{
			System.out.println("invalid age");
		}
	}
	public int getAge()
	{
		return age;
	}
}

class PersonDemoA
{
	public static void main(String[] args)
	{
		Person p = new Person();
		p.setAge(30);	//age: 30
		p.speak();		//age: 30
		p.setAge(-1);		//invalid age
		System.out.println(p.getAge());	//30
	}
}
```

-----

##### 2.1.2 构造函数

构造函数：在类中与类名相同函数。

构造函数：对象一建立就会调用与之对应的构造函数。
构造函数的作用：可以用于给对象进行初始化.

构造函数的小细节：当一个类中没有定义构造函数是，那么系统会默认给该类加入一个空参数的构造函数。
当在类中自定义了构造函数后，默认的构造函数被覆盖。

构造函数和一般函数在写法上有不同。

在运行上也有不同。

构造函数在对象一建立就运行，给对象初始化。

而一般方法是对象调用才执行，给是对象添加对象具备的功能。

一个对象建立，构造函数只运行一次。
而一般方法可以被改对象调用多次。

什么时候定义构造函数呢？
当分析事物时，该事物存在具备一些特性或者行为，那么将这些在构造函数中进行定义。

(05/PersonDemoB)

```java
class Person
{
	private String name;
	private int age;
	
	//构造函数
	Person()
	{
		System.out.println("A: My name is " + name + ",my age is " + age);
	}
	//构造函数重载
	Person(String n)
	{
		name = n;
		System.out.println("B: My name is " + name + ",my age is " + age);
	}
	//构造函数重载
	Person(String n, int a)
	{
		name = n;
		age = a;
		System.out.println("C: My name is " + name + ",my age is " + age);
	}

	public void cry()
	{
		System.out.println("My name is " + name + ",my age is " + age);
	}

	public void setName(String n)
	{
		name = n;
	}
}

class PersonDemoB
{
	public static void main(String[] args)
	{
		Person p1 = new Person();	//A: My name is null,my age is 0
		p1.cry();		//My name is null,my age is 0

		Person p2 = new Person("Li");	//B: My name is Li,my age is 0
		p2.cry();		//My name is Li,my age is 0

		Person p3 = new Person("Wang", 50);	//C: My name is Wang,my age is 50
		p3.cry();		//My name is Wang,my age is 50

		p3.setName("Wang Wuuuuuu");
		p3.cry();	//My name is Wang Wuuuuuu,my age is 50
	}
}

```

-----

##### 2.1.3 构造代码块

作用：给对象进行初始化。
对象一建立就运行，而且`优先于`构造函数执行（意味着新建对象自定义属性还没初始化，所以只能访问到类的属性初始化值 ）。

和构造函数的区别：
构造代码块是给所有对象进行统一初始化。

构造代码块中定义的是不同对象共性的初始化内容。

(05/PersonDemoC)

```java
class Person
{
	{	//构造代码块
		cry();
	}
	private String name;
	private int age;

	public void cry()
	{
		System.out.println("Cry: My name is " + name + ", my age is " + age);
	}

	Person (int a)
	{
		age = a;
	}

	Person(String n, int a)
	{
		name  = n;
		age = a;
	}
}

class PersonDemoC
{
	public static void main(String[] args)
	{
		Person p1 = new Person(22);	//Cry: My name is null, my age is 0
		p1.cry();	//Cry: My name is null, my age is 22

		Person p2 = new Person("Lisi", 88);	//Cry: My name is null, my age is 0
		p2.cry();	//Cry: My name is Lisi, my age is 88
	}
}
```

-----

##### 2.1.4 关键字`this`
看上去是用于区分局部变量和成员变量同名情况。

1.`this`为什么可以解决这个问题？

2.`this`到底代表什么？
`this`代表它所在函数所属对象的引用。
简单说：哪个对象在调用this所在的函数，`this`就代表那个对象。

类的实例化对象里面的成员变量都是由对象调用，`this`就指向这个对象。

(05/PersonDemoD)

```java
class Person
{
	private String name;
	private int age;

	Person(String name)
	{
		this.name = name;
	}
	Person(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public void cry()
	{
		System.out.println("Cry: My name " + name + ", my age is " + age);
	}
	public void cryThis()
	{
		System.out.println("CryThis: My name "+this.name+", my age is "+this.age);
	}
}
class PersonDemoD
{
	public static void main(String[] args)
	{
		Person p1 = new Person("LL");
		p1.cry();			//Cry: My name LL, my age is 0
		p1.cryThis();		//CryThis: My name LL, my age is 0

		Person p2 = new Person("KK", 322);
		p2.cry();			//Cry: My name KK, my age is 322
		p2.cryThis();		//CryThis: My name KK, my age is 322
	}
}
```

(05/PersonDemoE)

```java
class Person
{
	private String name;
	private int age;

	Person(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public int getAge()
	{
		return this.age;
	}

	public boolean compare(Person p)
	{
		return this.age == p.getAge();
	}
}
class PersonDemoE
{
	public static void main(String[] args)
	{
		Person p1 = new Person("LL", 10);

		Person p2 = new Person("KK", 22);

		System.out.println(p2.compare(p1));	//false
	}
}
```

`this语句`：用于构造函数间的相互调用。
`this语句`必须放在构造函数的第一行（一个构造函数中只能有一个`this语句`）;

(05/PersonDemoF)

```java
class Person
{
	private String name;
	private int age;

	Person(String name)
	{
		this.name = name;
	}
	Person(int age)
	{
		this.age = age;
	}
	Person(String name, int age)
	{
		this(name);	//this语句
		//this(age);	// 错误：对`this`的调用必须是构造器中的第一个语句
		this.age = age;
	}
	public void cry()
	{
		System.out.println("Cry: My name is " + name + ", my age is " + age);
	}
}

class PersonDemoF
{
	public static void main(String[] args)
	{
		Person p1 = new Person("LL", 30);
		p1.cry();	//Cry: My name is LL, my age is 30
	}
}
```

-----

##### 2.1.5 关键字`static`

###### 2.1.5.1 静态：`static`。
`静态方法只能访问静态成员！！！`
用法：是一个修饰符，用于修饰成员（非局部）（成员变量，成员函数）。
当成员被静态修饰后，就多了一个调用方式，除了可以被对象调用外，还可以直接被类名调用。类名.静态成员

###### 2.1.5.2 `static`特点：
（注：对象是类的实例。）
1.随着类的加载而加载；
	也就是说：静态会随着类的消失而消失。说明它的生命周期最长。
2.优先于对象存在；
	明确一点：静态是先存在的。对象是后存在的。
3.被所有对象所共享；
4.可以直接被类名所调用。

###### 2.1.5.3 实例变量和类变量的区别：

1.存放位置：
	类变量随着类的加载而存在于方法区中。
	实例变量随着对象的建立而存在于堆内存中。
2.生命周期：
	类变量生命周期最长，随着类的消失而消失。
	实例变量生命周期随着对象的消失而消失。

###### 2.1.5.4 静态使用注意事项：
1.`静态方法只能访问静态成员`。
	非静态方法既可以访问静态也可以访问非静态。
2.静态方法中不可以定义`this`, `super`关键字。
	因为静态优先于对象存在。所以静态方法中不能出现`this`, `super`关键字。 
3.主函数`main`是静态的。
4.静态方法中，所传的参数也是静态的

###### 2.1.5.5 静态有利有弊：
利：对对象的共享数据进行单独空间的存储，节省空间。没有必要每一个对象中都存储一份。
	可以直接被类名调用。

弊端：生命周期过长。
	访问出现局限性。（静态虽好，只能访问静态。）

(06/StaticA.java)

```java
class Person
{
	String name;
	static String country = "CN";

	Person(String name)
	{
		this.name = name;
	}

	public void show()
	{
		System.out.println(this.name+"....."+this.country);
	}

	public static void showB()
	{
		// System.out.println(this.name);//错误: 无法从静态上下文中引用非静态变量name
	}

	public static void showC()
	{
		System.out.println(country);
	}

	public void haha()
	{
		System.out.println("hahaaaaa");
	}
}

class StaticA
{
	public static void main(String[] args)
	{
		Person p1 = new Person("Lili");
		p1.show();	//Lili.....CN
		System.out.println(p1.country);		//CN
		System.out.println(Person.country);	//CN

		Person.showB();
		Person.showC();	//CN
	}
} 
```

(06/MainDemoA)

```java
class MainDemoA
{
	public static void main(String[] args)
	{
		// System.out.println()
		printArr(args);	//错误: 无法从静态上下文中引用非静态 方法 printArr(String[])
	}
	public void printArr(String[] args)
	{
		for(int i = 0; i < args.length; i++)
		{
			System.out.println(args[i]);
		}
	}
}
```

###### 2.1.5.6 什么时候使用静态？
要从两方面下手：
因为静态修饰的内容有成员变量和函数。

什么时候定义静态变量（类变量）？
>当对象中共享数据时，该数据被静态所修饰。
对象中的特有数据要定义成非静态存在于堆内存中。

什么时候定义静态函数？
>当功能内部没有访问到非静态数据（对象的特有数据），
那么该功能可以定义成静态的。

(06/StaticB)

```java
class Person
{
	String name;

	private static void showA()
	{
		System.out.println("AA haha"); 
	}

	public static void showB()
	{
		showA();
	}

	public static void showC()
	{
		System.out.println("CC HEHE");
	}
}

class StaticB
{
	public static void main(String[] args)
	{
		// Person.showA();	// 错误: showA()被 private 修饰，仅能在Person内部被访问
		Person.showB();	//AA haha
		Person.showC();	//CC HEHE
	}
}
```

###### 2.1.5.7 静态的应用--工具类 `ArrayTool`

每个应用程序中都有共性的功能，
可以将这些功能进行抽取，独立封装。
以便复用。

可以将`ArrayTool`中的方法都定义成`static`的。直接通过类名调用即可。

将方法都`static`后，可以方便于使用，但是该类还是可以被其他程序建立对象的。
为了更加严谨，强制让该类不能建立对象。
可以通过将构建函数私有化完成。

(06/ArrayTool/ArrayTool)

```java
package ArrayTool;

public class ArrayTool
{
	private ArrayTool()  //构造函数 `private` 修饰，不能实例化
	{

	}

	public static int getMax(int[] arr)
	{
		int max = arr[0];
		for(int x = 1; x < arr.length; x++)
		{
			if(arr[x] > max)
			{
				max = arr[x];
			}
		}
		return max;
	}

	public static int getMin(int[] arr)
	{
		int min = arr[0];
		for(int x = 1; x < arr.length; x++)
		{
			if(arr[x] < min)
			{
				min = arr[x];
			}
		}
		return min;
	}

	public static int[] selectSort(int[] arr)
	{
		for(int x = 0; x < arr.length-1; x++)
		{
			for(int y = x+1; y < arr.length; y++)
			{
				if(arr[x] > arr[y])
				{
					swap(arr, x, y);
				}
			}
		}
		return arr;
	}

	public static int[] bubbleSort(int[] arr)
	{
		for(int x = 0; x <arr.length -1; x++)
		{
			for(int y = 0; y < arr.length - x -1; y++)
			{
				if(arr[y] > arr[y+1])
				{
					swap(arr, y, y+1);
				}
			}
		}
		return arr;
	}

	public static void printArr(int[] arr)
	{
		System.out.print("[");
		for(int x = 0; x < arr.length; x++)
		{
			if(x == arr.length - 1)
			{
				System.out.println(arr[x]+"]");
			}
			else{
				System.out.print(arr[x]+", ");
			}
		}
	}

	private static void swap(int[] arr, int a, int b)
	{
		arr[a] = arr[a] ^ arr[b];
		arr[b] = arr[a] ^ arr[b];
		arr[a] = arr[a] ^ arr[b];
	}
}
```

(06/StaticToolDemo)

```java
import ArrayTool.ArrayTool;

class StaticToolDemo
{
	public static void main(String[] args)
	{
		int[] arrA = {9,2,4,1,5,6};
		System.out.println(ArrayTool.getMax(arrA));	//9

		System.out.println(ArrayTool.getMin(arrA));	//1

		ArrayTool.printArr(ArrayTool.selectSort(arrA));	//[1, 2, 4, 5, 6, 9]

		int[] arrB = {3,1,4,6,2,7,8};

		ArrayTool.printArr(ArrayTool.bubbleSort(arrB));	//[1, 2, 3, 4, 6, 7, 8]
	}
}
```

###### 2.1.5.8 静态代码块
格式：

```java
static
{
	静态代码块中的执行语句。
}
```

特点：随着类的加载而执行，只执行一次。
用于给类进行初始化的。

```java
class Demooo
{

}
class DemoMain
{
	public static void main(String[] args)
	{
		Demooo o = null;	//这样只声明变量类型，没有创建具体对象，
							//类`Demooo`不会被加载到内存中。
	}
}

```

(06/StaticCodeDemo)

```java
class StaticCode
{
	int num = 999;

	static
	{
		System.out.println("StaticCode_A, ");
	}

	{
		System.out.println("StaticCode_B, ");
	}

	StaticCode()
	{
		System.out.println("StaticCode_D, ");
	}

	StaticCode(int num)
	{
		this.num = num;
		System.out.println(this.num + " StaticCode_E, ");
	}

	public static void show()
	{
		System.out.println("StaticCode.show run, ");
	}

	static void show_B()
	{
		System.out.println("StaticCode.show_B run, ");
	}

	static
	{
		System.out.println("StaticCode_C, ");
	}
}

class StaticCodeDemo
{
	static
	{
		System.out.println("StaticCodeDemo_A, ");
	}

	public static void main(String[] args)
	{


		System.out.println("StaticCodeDemo_B, ");

		StaticCode.show();
		StaticCode.show_B();

		StaticCode c = new StaticCode(88);

		c.show();
		c.show_B();
		// Staticcccc bb = null;
	}

	static
	{
		System.out.println("StaticCodeDemo_C, ");
	}
}

//StaticCodeDemo_A, 
//StaticCodeDemo_C, 
//StaticCodeDemo_B, 
//StaticCode_A, 
//StaticCode_C, 
//StaticCode.show run, 
//StaticCode.show_B run, 
//StaticCode_B, 
//88 StaticCode_E, 
//StaticCode.show run, 
//StaticCode.show_B run, 
```

-----

##### 2.1.5 `javadoc`

一个类中默认会有一个空参数的构造函数，
这个默认的构造函数的权限和所属类一致。
如果类被`public`修饰，那么默认的构造函数也带`public`修饰符。
如果类没有被`public`，那么默认的构造函数，也没有`public`修饰。

想改变默认，则自定义构造函数，然后用`private`修饰。

	javadoc -d myhelp -author -version ArrayTool.java

-----

##### 2.1.6 主函数main
`plublic static void main(String[] args)`
主函数：是一个特殊的函数。作为程序的入口，可以被jvm调用。

主函数的定义：
>`public`：代表着该函数访问权限是最大的。
`static`：代表主函数随着类的加载就已经存在了。
`void`：主函数没有具体的返回值。
`main`：不是关键字，但是是一个特殊的单词，可以被jvm识别。
`(String[] args)`：函数的参数，参数类型是一个数组，该数组中的元素是字符串。字符串类型的数组。

主函数是固定格式的：jvm识别（可以重载主函数，但是jvm只识别固定格式的主函数，即: `public static void main(String[] args)` ）。

jvm在调用主函数时，传入的参数是new String[0];

(06/MainDemoB)

```java
class MainDemoB
{
	public static void main(String[] args)
	{
		System.out.println(args);    // [Ljava.lang.String;@2a139a55

		System.out.println(new String[0]); //[Ljava.lang.String;@15db9742
		// printArr(args);
	}
	public void printArr(String[] args)
	{
		for(int i = 0; i < args.length; i++)
		{
			System.out.println(args[i]);
		}
	}
}
```
(06/MainDemoC)

```java
class MainDemoC
{
	public static void main(String[] args)
	{
		String[] arr = {"AA", "BB", "CC", "DD", "EE"};
		MainTest.main(arr);	//[AA, BB, CC, DD, EE]
	}
}

class MainTest
{
	public static void main(String[] args)
	{
		for(int x = 0; x < args.length; x++)
		{
			System.out.println(args[x]);
		}
	}
}
```

-----

##### 2.1.7 对象的初始化过程

```java
Person p = new Person("zhangsan", 20);
```

该语句做了什么事情：
>1.因为`new`用到了`Person.class`文件，所以会先找到`Person.class`文件并加载到内存中
2.执行该类中的`static`代码块（如果`static`代码块存在），给`Person.class`类进行初始化。
3.在`堆内存`中开辟空间，分配内存地址。
4.在`堆内存`中建立对象的特有属性（仅仅指属性，不包括方法）。并进行`默认初始化`。
5.对属性进行`显式初始化`（分配给`对象`特有属性默认值）。
6.对对象进行`构造代码块`初始化。
7.对对象进行对应的`函数构造`初始化。
8.将内存地址赋值给栈内存中的p变量。

-----

##### 2.1.8 对象的调用过程

类内部调用
静态`static`省略`类名.`（Person.name）;
非静态省略`this.` （this.name）。

-----

#### 2.2 继承

##### 2.2.1 继承描述，关键字 `extends`

(07/ExtendsDemoA)

```java
class Person
{
	private int age;
	private String name;

	public void setName(String name)
	{
		this.name = name;
	}
	public String getName()
	{
		return this.name;
	}

}

class Student extends Person
{
	void study()
	{
		System.out.println("good study");
	}
}

class Worker extends Person
{
	void work()
	{
		System.out.println("good word");
	}
}

class ExtendsDemoA
{
	public static void main(String[] args)
	{
		Student s1 = new Student();
		s1.setName("TT");
		System.out.println(s1.getName());	//TT

		Worker w1 = new Worker();
		w1.setName("WW");
		System.out.println(w1.getName());	//WW
	}
}
```

`Student`类和`Worker`类都有共同属性`name`和`age`，
将共性描述提取出来，单独进行描述，
只要让`Student`和`Worker`单独描述的这个类有关系即可。

继承 `extends`：
1.提高了代码的复用性。
2.让类与类之间产生了关系。有了这个关系才有多态的特性。

>**注意：**
1.千万不要为了获取其他类的功能，简化代码而继承。
2.必须是类与类之间有所属关系才可以继承。 
3.子类`subclass`和父类`superclass`中存在同名方法时，`subclass`中的方法将覆盖父类`superclass`中的同名方法。

Java语言中：Java只支持单继承，不支持多继承。
因为存在安全隐患，如果多继承的父类中，存在着相同名字，不同内容的方法，
Java不确定该运行哪一个。

但是Java保留这种机制。并用另一种体现形式来完成表示————多实现。

Java支持多层继承。也就是一个继承体系(一脉相承)。

聚合：（球队：球员，球）
组合：（人体：手，心脏）（密切程度更高，球队可以少球员，人体不能少心脏）

-----

##### 2.2.2 子父类出现后，类成员的特点：

类中成员：

1· 变量。
2· 函数。
3· 构造函数。

**1.变量**

如果子类中出现非私有的同名成员变量时，
子类要访问本类中的变量，用this,
子类要访问父类中的同名变量，用super.

super的使用和this的使用几乎一致。
this代表的是本类对象的引用。
super代表的是父类对象的引用。 

(07/ExtendsDemoB)

```java
class Fu
{
	int num = 4;
}
class Zi extends Fu
{
	int num = 5;
	void showZi()
	{
		System.out.println(this.num);
	}
	void showFu()
	{
		System.out.println(super.num);
	}
}

class ExtendsDemoB
{
	public static void main(String[] args)
	{
		Zi z1 = new Zi();
		z1.showZi();	//5
		z1.showFu(); 	//4
	}
}
```

**2.函数**

当子类出现和父类一模一样的函数时，
当子类对象调用该函数，会运行子类函数的内容。
如同父类的函数被覆盖一样。

这种情况是函数的另一个特性：重写（覆盖）。

当子类继承父类，沿袭了父类的功能，到子类中，
但是子类虽具备该功能，但是功能的内容却和父类不一致，
这时，没有必要定义新功能，而是使用覆盖特殊，保留父类的功能定义，并重写功能内容。

覆盖：
1. 子类覆盖父类，必须保证子类权限大于等于父类权限，才可以覆盖，否则编译失败。 (private < 默认 < public)
2. 静态只能覆盖静态。

>**注意：**
重载：只看同名函数的参数列表。
重写：子父类方法要一模一样。（包括返回值，函数名和参数）

```java
class Tel
{
	void show()
	{
		System.out.println("number");
	}
}
class NewTel extends Tel
{
	void show()
	{
		super.show();
		System.out.println("name");
		System.out.println("pic");
	}
}

class ExtendsDemoC
{
	public static void main(String[] args)
	{
		NewTel t1 = new NewTel();
		t1.show();
	}
}
```

**3. 构造函数**

> 在对子类对象进行初始化时，父类的构造函数也会运行，
那是因为子类的构造函数默认第一行有一条隐式的语句 `super();`
`super();`:会访问父类中·`空参数`的构造函数。
而且子类中所有的构造函数默认第一行都是`super();`。

```java
class Fu
{
	Fu()
	{
		System.out.println("Fu run");
	}

	Fu(int x)
	{
		System.out.println("Fu run"+x);
	}
}

class Zi extends Fu
{
	Zi()
	{	
		//super();
		System.out.println("Zi run");
	}

	Zi(int num)
	{
		//super();
		System.out.println("Zi run"+num);
	}

	Zi(int x, int y)
	{
		super(x);
		System.out.println("Zi run"+y);
	}
}

class ExtendsDemoD
{
	public static void main(String[] args)
	{
		Zi z1 = new Zi(); //Fu run,  Zi run

		Zi z2 = new Zi(4);	//Fu run, Zi run4

		Zi z3 = new Zi(50, 80);	//Fu run50,  Zi run80
	}
}
```

***为什么子类一定要访问父类中的构造函数。***
>因为父类这种的数据子类可以直接获取。所以子类对象在建立时，需要先查看父类是如何对这些数据进行初始化的。
所以子类在对象初始化时，要先访问一下父类中的构造函数。
如果要访问父类中指定的构造函数，可以通过手动定义`super`语句的方式来指定。

***注意：***
`super`语句一定定义在子类构造函数第一行。


***子类的实例化过程***
>子类的所有的构造函数，默认都会访问父类中空参数得到的构造函数。
因为子类每一个构造函数内的第一行都有一句隐式`super()`;

>当父类中没有空参数的构造函数时，子类必须手动通过`super`语句形式来指定要访问父类中的构造函数。

>当然：子类的构造函数第一行也可以手动指定`this`语句来访问本类中的构造函数。
子类中至少会有一个构造函数会访问父类中的构造函数。

-----

##### 2.2.3 关键字 `final`

`final` : 最终。作为一个修饰符。

1. 可以修饰类，函数，变量。
2. 被 `final` 修饰的 `类` 不可以被继承。为了避免被继承，被子类复写功能。
3. 被 `final` 修饰的 `方法` 不可以被重写。
4. 被 `final` 修饰的 `变量` 是一个常量，只能复制一次，既可以修饰成员变量，又可以修饰局部变量。当描述事物时，一些数据的出现值是固定的，那么这是为了增强阅读性，都给这些值起个名字。方便于阅读 `final double PI = 3.14`。而这个之不需要改变，所以加上 `final`修饰。作为常量：常量的书写规范所有字母都是大写，如果由多个单词组成，单词间通过 `_` 连接( `FLY_SPEED` )。
5. 内部类定义在类中的局部位置上是，只能访问该局部被 `final` 修饰的局部变量。

(07/FinalDemo)

```java
final class Demo
{
	void show()
	{

	}
}
class DemoA
{
	final void show()
	{

	}

	void showA()
	{
		final int y = 4;
	}
}
```

-----

##### 2.2.4 抽象类

###### 2.2.4.1 抽象类的特点

>1. 抽象方法一定在抽象类中；
2. 抽象方法和抽象类都必须被 `abstract` 关键字修饰；
3. 抽象类不可以用 `new` 创建实例，因为调用抽象方法没有意义。
4. 抽象类中的抽象方法只要被使用，必须由子类 **复写其所有的抽象方法** 后，建立子类对象调用。如果子类只覆盖了部分抽象方法，那么该子类还是一个抽象类。


抽象类和一般类没有太大的不同。
该如何描述事物就如何描述事物，只不过该事物出现了一些看不懂的东西。
这些不确定的部分，也是该事物的功能，需要明确出现。但是无法定义主体。
通过抽象方法来表示。

抽象类比一般类多了抽象函数。
抽象类可以定义抽象方法。
抽象类不可以实例化。

抽象类可以理解成为了限定继承的类有特定的方法。
比如，继承 `Student` 抽象类的子类，必须要有 `study` 的方法。

**特殊：**

>抽象中可以不定义抽象方法，这样做仅仅是不让类实例化

(07/AbstractDemoB)

```java
abstract class Student
{
	abstract void study();

	void studyA()
	{
		System.out.println("Student study");
	}
}
class BaseStudent extends Student
{
	void study()
	{
		System.out.println("BaseStudent study");
	}
}

class AbstractDemoB
{
	public static void main(String[] args)
	{
		BaseStudent s1 = new BaseStudent();
		s1.study();			//BaseStudent study
		s1.studyA();		//Student study
	}
}
```

(07/AbstractDemoC)

```java
abstract class Employee
{
	private String name;
	private int id;
	private int pay;

	Employee(String name,int id, int pay)
	{
		this.name = name;
		this.id = id;
		this.pay = pay;
	}

	public void getCommonMessage()
	{
		System.out.println(this.name + "..." + this.id + "..." + this.pay);
	}

	public abstract void getMyMessage();

	public abstract void work();
}

class Manager extends Employee
{
	private int bonus;
	Manager(String name, int id, int pay, int bonus)
	{
		super(name, id, pay);
		this.bonus = bonus;
	}

	public void work()
	{
		System.out.println("Manager work");
	}

	public void getMyMessage()
	{
		System.out.println("Manage\'s bonus is " + this.bonus);
	}
}

class ProEmployee extends Employee
{
	private String skill;
	ProEmployee(String name, int id, int pay, String skill)
	{
		super(name, id, pay);
		this.skill = skill;
	}

	public void work()
	{
		System.out.println("ProEmployee work");
	}

	public void getMyMessage()
	{
		System.out.println("My skill is " + this.skill);
	}
}

class AbstractDemoC
{
	public static void main(String[] args)
	{
		Manager m1 = new Manager("jingli", 10, 20, 30);
		m1.getCommonMessage();	//jingli...10...20
		m1.work();				//Manager work
		m1.getMyMessage();		//Manage's bonus is 30

		ProEmployee p1 = new ProEmployee("dagong", 11, 22, "Java");
		p1.getCommonMessage();	//dagong...11...22
		p1.work();				//ProEmployee work
		p1.getMyMessage();		//My skill is Java
	}
}
```

**注意：**
>抽象类虽然不能实例化，但是依然有构造函数，可以自定义构造函数。

-----

##### 2.2.5 接口

接口： 初期理解，可以认为是一个特殊的抽象类，当抽象类中的方法都是抽象的，那么该类可以通过接口的形式来表示。

`class` 用于定义类
`interface` 用于定义接口

定义接口时，格式特点：

>1. 接口中常见定义：常量，抽象方法。
2. 接口中的成员都有固定修饰符。
	* 常量： `public static final`
	* 方法： `public abstract`

**记住：接口中的成员都是 `public` 的。**

**接口：**是不可以创建对象的，因为有抽象方法。
需要被子类实现(`implements`)，子类对接口中的抽象方法全都覆盖后，子类才可以实例化。否则子类是一个抽象类。

接口可以被类多实现（`implements`），也是对多继承不支持的转换形式。Java支持多实现。

```java
interface Inter
{
	public static final int NUM = 99;

	public abstract void show();
}

interface InterA
{
	public abstract void showA();
}

//接口可以继承接口
interface InterB extends InterA
{
	public abstract void showB();
}

class SupTest
{
	private int age;

	public void setAge(int age)
	{
		this.age = age;
	}

	public int getAge()
	{
		return this.age;
	}
}

//类可以同时继承类并且实现多个接口，所有继承来的及实现来的抽象方法必须具体化
class Test extends SupTest implements Inter, InterB	
{
	public void showA()
	{
		System.out.println("showA");
	}
	public void showB()
	{
		System.out.println("showB");
	}
	public void show()
	{
		System.out.println("Test");
	}
}

class InterfaceDemoA
{
	public static void main(String[] args)
	{
		Test t1 = new Test();
		t1.show();	//Test
		System.out.println(t1.NUM);		    //99
		System.out.println(Inter.NUM);		//99
		System.out.println(Test.NUM);		//99

		t1.setAge(55);
		System.out.println(t1.getAge());		//55

		t1.showA();		//showA
		t1.showB();		//showB

	}
}
```

-----

**接口的特点：**

>1. 接口是对外暴露的规则。
2. 接口是程序的功能扩展。
3. 接口是可以用来多实现。
4. 类与接口之间是实现关系，而且泪可以继承一个类的同时实现过个接口。
5. 接口与接口之间可以有继承关系。

(07/InterfaceDemoB)

```java
interface Singer
{
	public abstract void sing();
}

interface Runner
{
	public abstract void run(int distance);
}

class Student
{
	public void study()
	{
		System.out.println("Student study");
	}
}

class BaseStudent extends Student implements Singer
{
	public void sing()
	{
		System.out.println("BaseStudent sing: ");
	}

}

class AdvStudent extends Student implements Singer, Runner
{
	public void sing()
	{
		System.out.println("AdvStudent sing: ");
	}

	public void run(int distance)
	{
		System.out.println("AdvStudent run: " + distance);
	}
}

class InterfaceDemoB
{
	public static void main(String[] args)
	{
		BaseStudent b1 = new BaseStudent();
		b1.study();			//Student study
		b1.sing();			//BaseStudent sing: 

		AdvStudent a1 = new AdvStudent();
		a1.study();			//Student study
		a1.sing();			//AdvStudent sing:
		a1.run(111222);		//AdvStudent run: 111222
	}
}
```

**注意：**抽象方法定义了哪些参数，在具体化该方法时，就该传递哪些参数。虽然抽象方法没有主体，但是函数签名已经定好。

-------------------------------




#### 2.3 多态

##### 2.3.1 多态介绍

	1. 多态的体现
		父类的引用指向了自己的子类对象。
		父类的引用也可以接受自己的子类对象。

    2. 多态的前提
		必须是类与类之间有关系。要么继承（`extends`），要么实现（`implements`）。
		通常还有一个前提：存在覆盖。

    3. 多态的好处
		多态的出现大大的提高程序的拓展性。

	4. 多态的弊端
		提高了扩展性，但是只能使用父类的引用访问父类中的成员。

	5. 多态的应用

	6. 多态的出现代码中的特点（多态的注意事项）

在多态中 `成员函数（非静态）` 的特点：
在编译时期：参阅引用型变量所属的类中是否有调用的方法，如果有，编译通过；如果没有，编译失败。
在运行时期：参阅对象所属的类中是否有调用的方法。
简单总结就是：成员函数在多态调用时，编译看左边，运行看右边。

在多态中 `成员变量` 的特点：
无论编译还是运行，都参考左边（引用型变量所属的类）。

在多态中 `静态成员函数` 的特点：
无论编译还是运行，都参考左边。


##### 2.3.2 多态的转型

```java
abstract class Animal
{
	abstract public void shout();
}

class Cat extends Animal
{
	public void shout()
	{
		System.out.println("miao");
	}

	public void eat()
	{
		System.out.println("eat fish");
	}
}

class Dog extends Animal
{
	public void shout()
	{
		System.out.println("wang");
	}
	public void eat()
	{
		System.out.println("eat bone");
	}
}

class DuotaiDemoB
{
	public static void main(String[] args)
	{

		// 我们能转换的是父类应用指向了自己对象时，
		// 该应用可以被提升，也可以被强制转换。
		Animal cat = new Cat();
		cat.shout();

		Cat acat = (Cat)cat;
		acat.eat();

		// 报错，不能将父类对象转成子类类型。
		// 多态自始至终都是子类对象在做着变化。
		// Animal dog = new Animal();
		// Dog dog1 = (Dog)dog;
		
		Animal cat = new Cat();
		foo(cat);

		Animal dog = new Dog();
		foo(dog);
		

	}

	public static void foo(Animal a)
	{
		a.shout();

		if(a instanceof Cat)
		{
			Cat b = (Cat)a;
			b.eat();
		}else if(a instanceof Dog)
		{
			Dog b = (Dog)a;
			b.eat();
		}
	}
}
```

主板示例（08/MotherBoardA.java）
需求：
电脑运行实例，
电脑运行基于主板

```java
class MotherBoard
{
	public void run()
	{
		System.out.println("MotherBoard run");
	}

	public void runNetCard(NetCard c)
	{
		c.open();
		c.close();
	}
}

class NetCard
{
	public void open()
	{
		System.out.println("NetCard open");
	}

	public void close()
	{
		System.out.println("NetCard close");
	}
}

class MotherBoardA
{
	public static void main(String[] args)
	{
		MotherBoard m = new MotherBoard();
		m.run();
		m.runNetCard(new NetCard());
	}
}
```

(08/MotherBoardB.java)

```java
interface PCI
{
	public void open();
	public void close();
}

class NetCard implements PCI
{
	public void open()
	{
		System.out.println("NetCard run");
	}

	public void close()
	{
		System.out.println("NetCard close");
	}
}

class SoundCard implements PCI
{
	public void open()
	{
		System.out.println("SoundCard run");
	}
	public void close()
	{
		System.out.println("SoundCard close");
	}
}

class MotherBoardBBB
{
	public void run()
	{
		System.out.println("MotherBoardBBB run");
	}

	public void usePCI(PCI c)	//接口型引用指向自己的子类对象 
	{
		if(c ! = null)
		{
			c.open();
			c.close();
		}
	}
}

class MotherBoardB
{
	public static void main(String[] args)
	{
		MotherBoardBBB m = new MotherBoardBBB();
		m.run();
		m.usePCI(new NetCard());
		m.usePCI(new SoundCard());
	}
}
```

需求：数据库操作。

1.连接数据库
2.操作数据库
3.关闭数据库连接

(08/DBoperate.java)

```java

```

#### 2.4 equals()

`Object：`是所有对象的直接后者间接父类，传说中的上帝。该类中定义的肯定是所有对象都具备的功能。

```java
class Demo
{

}

class EqualsDemo
{
	public static void main(String[] args)
	{
		Demo d1 = new Demo();
		Demo d2 = new Demo();
		Demo d3 = d1;

		logEquals(d1, d2);	//false
		logEquals(d1, d3);	//true 

	}
	public static void logEquals(Object o1, Object o2)
	{
		System.out.println(o1.equals(o2));
	}
}
```

#### 2.5 toString()


#### 2.6 内部类

内部类的访问规则：
>1.内部类可以直接访问外部类的成员，包括私有。之所以可以直接访问外部类中的成员，是因为内部类中持有了一个外部类的引用，格式 `外部类名.this`
2.外部类要访问内部类，必须建立内部类对象

(09/InnerClassDemoA)

```java
class Outer
{
	public int x = 3;

	class Inner
	{
		int x = 5;
		void foo()
		{
			int x = 7;
			System.out.println(x+", "+this.x+", "+Outer.this.x);
		}
	}

	public void method()
	{
		Inner i = new Inner();

		i.foo();
	}
}

class InnerClassDemoA
{
	public static void main(String[] args)
	{
		Outer o = new Outer();
		o.method();		//7, 5, 3

		Outer.Inner o1 = new Outer().new Inner();
		o1.foo();	//7, 5, 3
	}
}
```

访问格式：
	
1.当内部类定义在外部类的成员位置上，而且非私有，可以在外部其他类中直接访问内部类对象。
格式：`外部类名.内部类名 变量名 = 外部类对象.内部类对象`;
eg: `Outer.Inner in = new Outer().new Inner()`;

2.当内部类在成员位置上，就可以被成员修饰符所修饰。
比如：
*`private`:将内部类在外部类中进行封装
*`static`：内部类就具备static的特性。当内部类被`static`修饰后，只能访问外部类中的`static`成员了，出现了访问局限。

*注意：*当 `内部类` 中定义了 `静态成员` ，该内部类必须是`static`的；当 `外部类` 中的 `静态方法` 访问 `内部类` 时，`内部类` 也必须是 `static`的。

(09/InnerClassDemoB)

```java
class Outer
{
	private static int n = 110000;

	public void method()
	{
		Inner i = new Inner();
		i.foo();
	}

	class Inner
	{
		void foo()
		{
			System.out.println(n);
		}
	}

	static class Inner0
	{
		void foo0()
		{
			System.out.println(n);
		}
	}

	static class Inner1
	{
		static void foo1()
		{
			System.out.println(n);
		}
	}
}

class InnerClassDemoB
{
	public static void main(String[] args)
	{
		Outer o1 = new Outer();
		o1.method();	//110000

		Outer.Inner i = new Outer().new Inner();
		i.foo();		//110000

		Outer.Inner0 i0 = new Outer.Inner0();
		i0.foo0();		//110000

		Outer.Inner1.foo1();	//110000
	}
}
```

当描述事物时，事物的内部还有事物，该事物用内部类来描述。
因为内部事物在使用外部事物的内容。



#### 2.7 匿名内部类

内部类定义在 `局部方法` 中时：
>1. 不可以被成员修饰符（`public private static final`）修饰；
2. 可以直接访问外部类中的成员，因为还持有外部类中的引用。但是不可以访问它所在的局部变量。只能访问被 `final` 修饰的局部变量（java 1.8 后可以直接访问）；

(09/InnerClassDemoC)

```java
class Outer
{
	int x = 3;

	static int y = 4;

	void method(final int bbb)
	{
		final int zzz = 10;

		class Inner
		{
			void foo()
			{
				System.out.println(Outer.this.x+", "+Outer.y);
			}

			void foo1()
			{
				System.out.println(zzz + ", " + bbb);
			}
		}

		Inner ii = new Inner();
		ii.foo();
		ii.foo1();
	}
}

class InnerClassDemoC
{
	public static void main(String[] args)
	{
		Outer oo = new Outer();
		oo.method(665);	//3, 4      10, 665

		oo.method(332);	//3, 4      10, 332
		
	}
}
```

匿名内部类
>1.匿名内部类其实就是内部类的简写格式。
2.定义匿名内部类的前提：匿名内部类必须是继承一个类或者实现接口
3.匿名内部类的格式：new 父类或者接口(){定义子类的内容}
4.其实匿名内部类就是一个匿名子类对象。而且这个对象有点胖。可以理解为带内容的对象
5.匿名内部中定义的方法最好就是不要超过3个。

(09/InnerClassDemoD)

```java
abstract class AbsDemo
{
	abstract void show();
}

class Outer
{
	int x = 10;
	public void foo()
	{
		new AbsDemo()
		{
			void show()
			{
				System.out.println("x = " + x);
			}
		}.show();

		new AbsDemo()
		{
			void show()
			{

			}
			void hh()
			{
				System.out.println("hh");
			}
		}.hh();

		new AbsDemo()
		{
			int x = 99;
			void show()
			{
				System.out.println(x + " , " + Outer.this.x);
			}
		}.show();
	}
}

class InnerClassDemoC
{
	public static void main(String[] args)
	{
		Outer o = new Outer();
		o.foo();
		// x = 10
		// hh
		// 99 , 10
	}
}
```

(09/InnerClassDemoE)

```java
interface Inter
{
	void method();
}

class Test
{
	public static Inter foo()
	{
		return new Inter()
			   {
			   		public void method()
			   		{
			   			System.out.println("Test Inter");
			   		}
			   };
	}
}

class TestA
{
	static void foo()
	{
		new Object()
		{
			public void fooO()
			{
				System.out.println("DEDDDD");
			}
		}.fooO();
	}
}

class InnerClassDemoE
{
	public static void main(String[] args)
	{
		Test.foo().method();
		TestA.foo();
	}
}
```

#### 2.8 异常

##### 2.8.1 异常简介

`异常：` 就是程序在运行时，出现不正常情况。
`异常由来：` 问题也是显示生活中一个具体的事物，也可以通过java的类的形式进行描述。并封装成对象。其实就是java对不正常情况进行描述后的对象体现。
`对于问题的划分：` 两种:1.一种是严重的问题，一种是非严重的问题。
	
	对于严重的，java通过 `Error` 类进行描述,
		对于 `Error` 一般不编写针对性的代码对其进行处理。
	对于非严重的，java通过 `Exception` 类进行描述,
		对于 `Exception` 可以使用针对性的处理方式进行处理。

无论 `Error` 或者 `Exception` 都具有一些共性内容。
比如：不正常情况的信息，引发原因等。

Throwable
	|--Error
	|--Exception



##### 2.8.2 异常的处理

java提供了特有的语句进行处理。

```java
try
{
	需要被检测的代码;
}
catch(异常类 变量)
{
	处理异常的代码;处理方式
}
finally
{
	一定会执行的语句;
}
```

对捕获到的异常对象进行常见方法操作。

	e.toString();
	e.getMessage();
	e.printStackTrace();


(09/ExceptionDemoA)

```java
class Demo
{
	public int divide(int a, int b)
	{
		return a/b;
	}
}

class ExceptionDemoA
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		// d.divide(4, 0);

		try
		{
			d.divide(4, 0);
		}
		catch(Exception e)
		{
			Log(e.getMessage());	// 异常信息
			Log(e.toString());		// 异常名称，异常信息
			e.printStackTrace();	// 异常名称，异常信息，异常出现的位置。
									// jvm默认的异常处理
		}
		System.out.println("Over");

	}

	public static void Log(String a)
	{
		System.out.println(a);
	}
}
```
 
(09/ExceptionDemoB)

```java
class Demo
{
	int divide(int a, int b) throws Exception
	{
		return a/b;
	}

	int divide1(int a, int b)
	{
		return a/b;
	}
}

class ExceptionDemoB
{
	//throws Exception
	public static void main(String[] args)	
	{
		Demo d = new Demo();
		try
		{
			d.divide(4, 0);
		}
		catch(Exception e)
		{
			System.out.println(e.toString());
		}
	}
}
```

##### 2.8.3 多异常的处理

1.声明异常时，建议声明更为具体的异常。这样处理的可以更具体。
2.对方声明几个异常，就对应有几个 `catch` 块。不要定义多余的 `catch` 块。如果多个 `catch` 块中的异常出现继承关系，父类异常 `catch` 块放在最下面。

(09/ExceptionDemoC)

```java
class Demo
{
	public int divide(int a, int b) throws ArithmeticException, ArrayIndexOutOfBoundsException
	{
		int[] arr = new int[a];
		int aa = arr[a];

		return a/b;
	}
}


class ExceptionDemoC
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		try
		{
			d.divide(4, 0);
		}
		catch(ArithmeticException e)
		{
			Log(e.toString());
		}
		catch(ArrayIndexOutOfBoundsException e)
		{
			Log(e.toString());
		}
		catch(Exception e)
		{
			Log(e.toString());
		}
		Log("Over");
	}
	public static void Log(Object a)
	{
		System.out.println(a);
	}
}
```

##### 2.8.4 自定义异常

继承Exception原因：
`异常体系有一个特点：` 因为异常类和异常对象都被抛出。他们都具备可抛性，这个是Throwable这个体系中独有的特点。

只有这个体系中的类和对象才可以被 `throws` 和 `throw` 操作。

`thorw` 和 `thorws` 的区别：
	
	throws使用在函数上；
	throw使用在函数内；

	throws后面跟的异常类。可以跟多个，用逗号隔开。
	throw后面跟的是异常对象。

(09/ExceptionDemoD)

```java
class NegativeException extends Exception
{
	NegativeException()
	{

	}

	private int value;
	NegativeException(String msg, int value)
	{
		super(msg);
		this.value = value;
	}

	public int getValue(){
		return this.value;
	}

}

class Demo
{
	public int divide(int a, int b) throws NegativeException, ArithmeticException
	{
		if(b < 0)
		{
			throw new NegativeException("Negative value", b);
		}
		return a/b;
	}
}

class ExceptionDemoD
{
	public static void main(String[] args)
	{
		Demo d = new Demo();

		try
		{
			d.divide(4, -1);
		}
		catch(NegativeException e)
		{
			System.out.println(e.toString());
		}
		catch(ArithmeticException e)
		{
			System.out.println(e.toString());
		}
		System.out.println("Over");
	}
}
```

##### 2.8.5 RuntimeException

`Exception` 中有一个特殊的子类异常 `RuntimeException`：运行时异常。

如果在函数内容抛出（`throw`）该异常，函数上可以不用声明，编译可以通过。

如果在函数上（`thorws`）声明了该异常。调用者可以不用进行处理。编译可以通过。

之所以不用在函数声明，是因为不需要让调用者处理。
当该异常发生，希望程序停止。因为在运行时，出现了无法继续运算的情况，希望停止程序后，对代码进行修正。

自定义异常时：如果该异常的发生，导致程序无法继续运算，就让自定义异常继承 `RuntimeException`。

对于异常，分两种：

1.编译时被检测的异常，编译不能通过。
2.编译时不被检测的异常，（运行时异常。`RuntimeException` 以及其子类）。

(09/ExceptionDemoE)

```java
class FuShuException extends RuntimeException
{
	FuShuException(String msg)
	{
		super(msg);
	}
}

class Demo
{
	public int divide(int a, int b)
	{
		if(b == 0)
		{
			//只抛出了 `FuShuException`，调用代码及函数上没有处理。
			throw new FuShuException("Zero Zero Zero Zero!!!!");
		}

		return a/b;
	}
}


class ExceptionDemoE
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		d.divide(4, 0);
		System.out.println("over");
	}
}
```

(09/ExceptionDemoF)

需求：
讲师用电脑上课。
电脑可能出现问题，如蓝屏，冒烟。
要对问题描述封装成对象。

电脑蓝屏，讲师可以重启电脑。
电脑冒烟，导致课时完成不了。讲师只能让学生做练习。

```java
class LanPingException extends Exception
{
	LanPingException(String msg)
	{
		super(msg);
	}
}

class MaoYanException extends Exception{
	MaoYanException(String msg)
	{
		super(msg);
	}
}

class Computer
{
	private int state = 2;

	public void run() throws LanPingException, MaoYanException
	{
		if(state == 2)
		{
			throw new LanPingException("Blue Blue! Must be Restart!");
		}
		if(state == 3)
		{
			throw new MaoYanException("MaoYanLe!");
		}

		System.out.println("Computer Run Right!");
	}

	public void restart()
	{
		System.out.println("Computer Restarting!");
		state = 1;
	}
}

class NoPlanException extends Exception
{
	NoPlanException(String msg)
	{
		super(msg);
	}
}

class Teacher
{
	private String name;

	Teacher(String name)
	{
		this.name = name;
	}

	public void prelect() throws NoPlanException
	{
		Computer c = new Computer();
		try
		{
			c.run();
		}
		catch(LanPingException e)
		{
			System.out.println(e.toString());
			c.restart();
		}
		catch(MaoYanException e)
		{
			test();
			throw new NoPlanException("Computer Broken,"+e.getMessage()+", Can not complete plan!");
		}
		System.out.println("Prelect Right!");
	}

	public void test()
	{
		System.out.println("Do Some Exercise!!!");
	}
}


class ExceptionDemoF
{
	public static void main(String[] args)
	{
		Teacher t = new Teacher("BiBi");
		try
		{
			t.prelect();
		}
		catch(NoPlanException e)
		{
			System.out.println(e.toString());
		}
	}
}
```

##### 2.8.6 异常finally

`finally` 代码块：一定会执行！
通常用于关闭资源，或者执行一些一定要执行的代码。

(10/FinallyDemoA)

```java
class FuShuException extends Exception
{
	FuShuException(String msg)
	{
		super(msg);
	}
}

class Demo
{
	public int divide(int a, int b) throws FuShuException
	{
		if(b < 0)
		{
			throw new FuShuException("FuShu!!!!");
		}
		return a/b;
	}
}

class FinalDemoA
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		try
		{
			System.out.println(d.divide(4, -1));
		}
		catch(FuShuException e)
		{
			System.out.println(e.toString());
		}
		finally
		{
			System.out.println("Finally!!!");
		}
		System.out.println("Over");
	}
}
```

(10/FinallyDemoB)

**注意**：`catch` 是用于处理异常。如果没有 `catch` 就代表异常没有被处理过，如果该异常是 `检测时异常（不能通过编译）` 。那么必须声明。

```java
class Demo
{
	public void foo() throws Exception
	{
		try
		{
			throw new Exception();
		}
		finally
		{
			System.out.println("Close Source!!!");
		}
	}
}

class FinallyDemoB
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		try
		{
			d.foo();
		}
		catch(Exception e)
		{
			System.out.println(e.toString());
		}
		System.out.println("Over");
	}
}
```

##### 2.8.7 覆盖时的异常特点

异常在字父类覆盖中的体现：
1.子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法，只能抛出父类的异常或者该异常的子类。因为考虑出于 `多态` 的情况，前期的代码无法处理后期出现的异常。
2.如果父类方法抛出多个异常，那么子类在覆盖方法时，只能抛出父类异常的子集。
3.如果父类或者接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常。如果子类方法发生了异常，就必须要在内部进行 `try catch`处理。绝对不能抛出。

(10/ExceptionDemoH)

```java
class AException extends Exception
{
	AException(String msg)
	{
		super(msg);
	}
}
class AaException extends AException
{
	AaException(String msg)
	{
		super(msg);
	}
}

class BException extends Exception
{
	BException(String msg)
	{
		super(msg);
	}
}

class Fu
{
	public void fooA() throws AException
	{

	}
	public void fooB() throws AException
	{

	}
	public void fooC()
	{

	}
}

class Test
{
	public void foo(Fu f)
	{
		try
		{
			f.fooA();
		}
		catch(AException e)
		{
			System.out.println(e.toString());
		}
	}
}

class Zi extends Fu
{
	public void fooA() throws AaException
	{

	}

	// public void fooB() throws BException
	// {
			// 错误：
			// Zi中的fooB()无法覆盖Fu中的fooB()
	    	// public void fooB() throws BException
			// 被覆盖的方法未抛出BException
			// 
			// 子类覆盖方法时，抛出的异常必须是父类方法抛出的异常的类或者子类
	// }

	// public void fooC() throws AException
	// {
			// 错误：
			// Zi中的fooC()无法覆盖Fu中的fooC()
	        // public void fooC() throws AException
			// 被覆盖的方法未抛出AException
			// 
			// 子类覆盖方法时，如果父类该方法没有异常抛出，
			// 那么子类该方法也不能抛出异常
	// }
}

class ExceptionDemoH
{
	public static void main(String[] args)
	{
		Test t = new Test();
		t.foo(new Fu());
	}
}
```

##### 2.8.8 异常练习

###### 2.8.8.1 获取图形面积

(10/ExceptionDemoI)

```java
interface Shape
{
	public void getArea();
}

class IllegalValueException extends RuntimeException
{
	IllegalValueException(String msg)
	{
		super(msg);
	}
}

class Rectangle implements Shape
{
	private int length, width;
	Rectangle(int length, int width)
	{
		if(length <=0 || width <= 0)
		{
			throw new IllegalValueException("IllegalValue");
		}
		this.length = length;
		this.width = width;
	}

	public void getArea()
	{
		System.out.println(length * width);
	}
}

class Circle implements Shape
{
	private int radius;
	public static final double PI = 3.14;
	Circle(int radius)
	{
		if(radius <= 0)
		{
			throw new IllegalValueException("IllegalValue");
		}
		this.radius = radius;
	}

	public void getArea()
	{
		System.out.println(radius * radius * PI);
	}
}

class ExceptionDemoI
{
	public static void main(String[] args)
	{
		Rectangle r = new Rectangle(-1, 2);
		r.getArea();

		Circle c = new Circle(-5);
		c.getArea();

		System.out.println("over");
	}
}
```

##### 2.8.9 异常总结

异常：是对问题的描述。将问题进行对象的封装。 

异常体系：

* Throwable
	* Error
	* Exception
		* RuntimeException

**异常体系的特点：**异常体系中的所有类以及建立的对象都具备可抛性，也就是所可以被 `throw` 和 `throws` 关键字所操作。只有异常体系具备这个特点。

----------------------------

`throw` 和 `throws` 的用法：

* `throw` 定义在函数内，用于抛出异常对象。
* `throws` 定义在函数上，用于抛出异常类，可以抛出多个用逗号隔开。

当函数内容有 `throw` 抛出异常对象，并未进行 `try` 处理。必须在函数上声明（`thorws`），否则编译失败。*注意,* `RuntimeException` 除外。 也就说，函数内如果抛出的是 `RuntimeException` 异常，函数上可以不声明（`throws`）。

如果函数声明了异常，调用者需要进行处理。处理方法可以 `throws` 可以 `try`。

----------------------------

异常有两种：

 * **编译时被检测异常：** 该异常在编译时，如果没有处理（没有 `throws` 也没有 `try`），编译失败。该异常被标识，代表这可以被处理。
 * **运行时异常（编译时不检测）：** 在编译时，不需要处理，编译器不检查。该异常发生，建议不处理，让程序停止。需要对代码进行修正。

----------------------------

异常处理语句：

```java
try
{

}
catch()
{

}
```

```java
try
{

}
finally
{

}
```

```java
try
{
	//被检测语句
}
catch()
{
	//异常处理语句
}
finally
{
	//最终必定会执行到的语句
}
```

**注意：**

1. `fianlly` 中定义的通常是 `关闭资源代码`，因为资源必须释放。
2. `fianlly` 只有一种情况不会执行。 当执行到 `System.exit(0);` 时， `finally` 不会执行。

----------------------------

自定义异常：定义类继承 `Exception` 或者 `RuntimeException`。

1. 为了让自定义类具备可抛性。
2. 让该类具备操作异常的共性方法。

当要定义自定义异常的信息时，可以使用父类已经定义好的功能。将异常信息传递给父类的构造函数。

```java
class MyException extends Exception
{
	MyException(String msg)
	{
		super(msg);
	}
}
```

自定义异常：按照Java的面向对象思想，将程序中出现的特有问题进行封装。

----------------------------

异常的好处：

1. 将问题进行封装。
2. 将正常流程代码和问题处理代码相分离，方便于阅读。

异常的处理原则：

1. 处理方式有两种：`try` 和 `throws`。
2. 调用到抛出异常的功能时，抛出几个，就处理几个。一个 `try` 对应多个 `catch`。
3. 有多个 `catch`时，处理父类异常的 `catch` 放到最下面。
4. `catch` 内，需要定义针对性的处理方式。不要简单的定义 `printStackTrace`，输出语句，也不要不写。

当捕获到的异常，本功能处理不了时，可以继续在 `catch` 中抛出。

```java
try
{
	throw new AException();
}
catch(AException e)
{
	throw e;
}
```

如果该异常处理不了，但并不属于该功能出现的异常。
可以将异常转换后，再抛出和该功能相关的异常。

或者异常可以处理，当需要将异常产生的和本功能相关的问题提供处理，让调用者知道，并处理。也可以将捕获异常处理后，转换新的异常。

```java
try
{
	throw new AException();
}
catch(AException e)
{
	//对AException进行处理。
	throw new BException();
}
```

----------------------------

异常的注意事项：
在子父类覆盖时：

1. 子类抛出的异常必须是父类的异常的子类或者子集。
2. 如果父类或者接口没有异常抛出时，子类覆盖出现异常，只能内部处理（`try`），不能抛出。

----------------------------

#### 2.9 包管理

##### 2.9.1 关键字 `package` `protected`

(10/package/PackageDemoB.java)

```java
package packb;

public class PackageDemoB
{
	public void run()
	{
		System.out.println("PackageDemoB run!");
	}
	protected void show()
	{
		System.out.println("PackageDemoB protected run!");
	}
}
```

(10/package/PackageDemoA.java)

```java
package packa;

public class PackageDemoA extends packb.PackageDemoB
{
	public void run()
	{
		System.out.println("PackageDemoA Run!");

		show();
	}
}
```

(10/package/PackageDemo.java)

```java
package pack;

class PackageDemo
{
	public static void main(String[] args)
	{
		System.out.println("Hello world! PackageDemo.");
		packa.PackageDemoA a = new packa.PackageDemoA();
		a.run();

		packb.PackageDemoB b = new packb.PackageDemoB();
		b.run();
		// b.show();	//错误：非子类无法访问其他包中被的 `protected` 修饰的方法
	}
}
```

----------------------------

**总结：**

1. 包与包之间进行访问，被访问的包中的类以及类中的成员，需要 `public` 修饰。
2. 不同包中的 `子类` 还可以直接访问 `父类` 中被 `protected` 权限修饰的成员。

包与包之间可以使用的权限只有两种，`public` `protected`

##### 2.9.2 关键字 `import`

(10/import/PackageDemo.java)

```java
package pack;

import packa.PackageDemoA;
import packb.PackageDemoB;

class PackageDemo
{
	public static void main(String[] args)
	{
		System.out.println("Hello world! PackageDemo.");
		PackageDemoA a = new PackageDemoA();
		a.run();

		PackageDemoB b = new PackageDemoB();
		b.run();
		// b.show();	//错误
	}
}
```

**注意：**如果不同命名空间下，存在同样的类名，类名引用时必须带上命名空间。

----------------------------

##### 2.9.3 jar包

```
jar -cf test.jar pack packa packb
```

----------------------------

## 多线程

### 1 多线程初阶

#### 1.1 概述

**进程：**是一个正在执行中的程序。每一个进程执行都有一个执行顺序。该顺序是一个执行路径，或者叫一个控制单元。
**线程：**就是进程中的一个独立的控制单元。线程在控制着进程的执行。一个进程至少有一个线程。

`Java VM` 启动的时候会有一个进程 `java.exe`.

该进程中至少一个线程负责 `Java` 程序的执行。
而且这个线程运行的代码存在于 `main` 方法中。
该线程称之为 `主线程`。

(11/ThreadDemoA)

```java
class ThreadDemoA
{
	public static void main(String[] args)
	{
		for(int x = 0; x < 400; x++)
		{
			System.out.println("Hello world!");
		}
	}
}
```

-----

#### 1.2 线程创建（创建多线程的第一种方式 `exttends Thread`）

通过对API的查找（`java.lang.Thread`），`Java` 已经提供了对线程这类事物的描述。即 `Thread` 类。

创建线程的第一种方式：继承 `Thread` 类。
**步骤：**

1. 定义类继承 `Thread`。
2. 复写 `Thread` 类中的 `run` 方法。目的：将自定义的代码存储在 `run` 方法中，让线程运行。
3. 调用线程的 `start` 方法，该方法有两个作用：启动线程，调用 `run` 方法。

(11/ThreadDemoB)

```java
class Demo extends Thread
{
	public void run()
	{
		for(int x=0; x < 60; x++)
		{
			System.out.println("DDDDDDDDDemo run--"+ x);
		}
	}
}

class ThreadDemoB
{
	public static void main(String[] args)
	{
		Demo d = new Demo();
		d.start();

		for(int x = 0; x < 60; x++)
		{
			System.out.println("Main run--"+x);
		}
	}
}
```

发现运行结果每次都不同。
因为多个线程都获取 cpu 的执行权。 cpu 执行到谁，谁就运行。
明确一点，在某一个时刻，只能有一个程序运行（多核 cpu 除外）
cpu 在做着快速的切换，以达到看上去是同时运行的效果。
我们可以形象把多线程的运行行为在互相抢夺 cpu 的控制权。
这就是多线程的一个特性：随机性。谁抢到谁执行，至于执行多长，cpu 说的算。

**为什么要覆盖 `run` 方法？**
`Thread` 类用于描述线程。
该类中定义了一个功能，用于存储线程要运行的代码。该存储功能就是 `run` 方法。
也就是说 `Thread` 类中的 `run` 方法，用于存储线程要运行的代码。

-----

#### 1.3.多线程练习

(11/ThreadExerciseA)

```java
class Test extends Thread
{
	private String name;
	Test(String name)
	{
		this.name = name;
	}

	public void run()
	{
		for(int x = 0; x < 60; x++)
		{
			System.out.println(this.name+":"+x);
		}
	}
}

class ThreadExerciseA
{
	public static void main(String[] args)
	{
		Test t1 = new Test("AAAAAAAA");
		Test t2 = new Test("BBBBB");
		t1.start();
		t2.start();

		for(int x = 0; x < 60; x++)
		{
			System.out.println("Main:"+x);
		}
	}
}
```

-----

#### 1.4 线程的运行状态

**五种状态：**

* 被创建
* 运行（`start()`）
* 冻结（放弃了执行资格）
	* 睡眠
		* `sleep(time)`
		* `sleep` 时间到
	* 等待
		* `wait()`
		* `notify()`
* 消亡（stop()，`run` 方法结束）
* 临时状态（阻塞状态）

-----

#### 1.5 获取线程对象以及名称

每个线程都有自己默认的名称。
`Thread-编号` 该编号从 `0` 开始。

`static Thread currentThread()` 获取当前线程对象。
`getName()`：获取线程名称。
设置线程名称：`setName()` 或构造函数。

(11/ThreadDemoC)

```java
class Demo extends Thread
{
	Demo(String name)
	{
		super(name);
	}

	public void run()
	{
		for(int x = 0; x < 60; x++)
		{
			System.out.println((Thread.currentThread()==this)+"..."+this.getName() +":"+x);
		}
	}
}

class ThreadDemoC
{
	public static void main(String[] args)
	{
		Demo d = new Demo("AA---");
		Demo d2 = new Demo("BB+++");
		d.start();
		d2.start();

		for(int x = 0; x < 60; x++)
		{
			System.out.println("Main:***"+x);
		}
	}
}
```

-----

#### 1.6 售票例子（创建多线程的第二种方式 `implements Runnable`）

(11/TicketDemoA) 

```java
class Ticket extends Thread
{
	private static int ticks = 100;

	public void run()
	{
		while(ticks > 0)
		{
			System.out.println(currentThread().getName() + "....." +ticks);
			ticks--;
		}
	}
}

class TicketDemoA
{
	public static void main(String[] args)
	{
		Ticket t = new Ticket();
		Ticket t1 = new Ticket();
		Ticket t2 = new Ticket();

		t.start();
		t1.start();
		t2.start();
	}
}
```

创建线程的第二种方式：实现 `Runnable` 接口

**步骤：**

1. 定义类 实现（`implements`）`Runnable` 接口
2. 覆盖 `Runnable` 接口中的 `run` 方法。将线程要运行的代码存放在该 `run` 方法中。
3. 通过 `Thread` 类建立线程对象。
4. 将 `Runnable` 接口的子类对象作为实际参数传递给 `Thread` 构造函数。
5. 调用 `Thread` 类的 `start` 方法开启线程并调用`Runnable` 接口子类的 `run` 方法。

**为什么要将 `Runnable` 接口的子类对象传给 `Thread` 的构造函数。**
	
	因为，自定义的 `run` 方法所属的对象是 `Runnable` 接口的子类对象。
	所以要让先线程去执行指定对象的 `run` 方法。就必须明确该 `run` 方法所属对象。

**实现方式（`implements`）和继承方式（`extends`）有什么区别？**

	实现（`implements`）方式好处：避免了单继承的局限性。
	在定义线程是，建议使用实现方式（`implements`）。

**两种方式的区别：**

	继承（`extends`）`Thread`：线程代码存放 `Thread` 子类 `run` 方法中。
	实现 `Runnable`，线程代码存在 `Runnable接口` 的子类的 `run` 方法。

(11/TicketDemoB)

```java
class Ticket implements Runnable
{
	private int ticks = 100;

	public void run()
	{
		while(ticks > 0)
		{
			System.out.println(Thread.currentThread().getName() + "..." + ticks);
			ticks--;
		}
	}
}

class TicketDemoB
{
	public static void main(String[] args)
	{
		Ticket t = new Ticket();

		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);

		t1.start();
		t2.start();
		t3.start();
		t4.start();
	}
}
```

-----

#### 1.7 多线程安全问题 

卖票的例子：

(11/TicketDemoC)

```java
class Ticket implements Runnable
{
	private int ticks = 300;
	public void run()
	{
		while(ticks > 0)
		{
			try
			{
				Thread.sleep(10);
			}
			catch(Exception e)
			{
				System.out.println(e);
			}
			System.out.println(Thread.currentThread().getName() + "...." + ticks);
			ticks--;
		}
	}
}

class TicketDemoC
{
	public static void main(String[] args)
	{
		Ticket t = new Ticket();

		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);

		t1.start();
		t2.start();
		t3.start();
		t4.start();
	}
}
```

通过分析，发现，打印出0, -1, -2等结果。

多线程的运行安全问题。

**问题原因：**

	当多条语句在操作同一个线程共享的数据时，一个线程对多条语句只执行了一部分，还没有执行完，
	另一个线程参与进来执行。导致共享数据的错误。

**解决办法：**
	
	对多条操作共享数据的语句，只能让一个线程都执行完。在执行过程中，其他线程不可以参与执行。

Java 对多线程的安全问题提供了专业的解决方式。
**同步代码块。**

```java
synchronized(对象)
{
	需要被同步的代码
}
```

对象如同锁（锁旗标）。持有锁的线程可以在同步中执行。
没有持有锁的线程即使获取cpu的执行权，也进不去，因为没有获取锁。
（火车卫生间）

**同步的前提：**

	1. 必须要有两个或者两个以上的线程；
	2. 必须是多个线程使用同一个锁；

必须保证同步中只能有一个线程在运行。

**好处：**解决了多个线程的安全问题。
**弊端：**多个线程需要判断锁，较为消耗资源

(11/TicketDemoD)

```java
class Ticket implements Runnable
{
	private int ticks = 1000;

	Object obj = new Object();

	public void run()
	{
		while(true)
		{
			synchronized(obj)
			{
				if(ticks > 0)
				{
					try
					{
						Thread.sleep(10);
					}
					catch(Exception e)
					{
						System.out.println(e);
					}
					System.out.println(Thread.currentThread().getName() +"."+ticks);
					ticks--;
				}
			}
			if(ticks == 0){
				return;
			}
		}
	}
}

class TicketDemoD
{
	public static void main(String[] args)
	{
		Ticket t = new Ticket();

		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		t1.start();
		t2.start();
		t3.start();
		t4.start();

	}
}
```

(11/TicketDemoDD) **错误的DEMO**

```java
class Ticket implements Runnable
{
	private int ticks = 1000;

	Object obj = new Object();

	public void run()
	{
		synchronized(obj)
		{
			while(ticks > 0)
			{
				//直到买完票都满足ticks > 0，
				//所以会在这代码块里一直一直执行
				try
				{
					Thread.sleep(10);
				}
				catch(Exception e)
				{
					System.out.println(e);
				}
				System.out.println(Thread.currentThread().getName() + "." + ticks);
				ticks--;
			}
		}
	}
}

class TicketDemoDD
{
	public static void main(String[] args)
	{
		Ticket t = new Ticket();

		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);
		Thread t3 = new Thread(t);
		Thread t4 = new Thread(t);
		t1.start();
		t2.start();
		t3.start();
		t4.start();

	}
}
```

-----

#### 1.8 同步函数

需求：
	
	银行有个一金库。
	有两个储户分别存300元，每次存100，存3次。

寻找多线程安全问题：
	
	1. 明确哪些代码是多线程运行代码；
	2. 明确共享数据；
	3. 明确多线程运行代码中那些语句是操作共享数据的。

**该DEMO代码例子不太合适，代码实际上是只 `new` 了一个 `Cus`。**
**应该理解为一个储户，在一个银行的两个窗口存钱，每个窗口存3次，每次存100。**
**要解决的安全问题是：每次在一个窗口进行一次存款行为完毕后，再去做下一次存款行为。**

(11/BankDemoA)

```java
class Bank
{
	private int sum;
	public synchronized void add(int n)
	{
		try
		{
			Thread.sleep(10);
		}
		catch(Exception e)
		{

		}
		sum += n;
		System.out.println(sum);
	}
}

class Cus implements Runnable
{
	Bank b = new Bank();
	public void run()
	{
		for(int x = 0; x < 3; x++)
		{
			b.add(100);
		}
	}
}

class BankDemoA
{
	public static void main(String[] args)
	{
		Cus c = new Cus();
		Thread t1 = new Thread(c);
		Thread t2 = new Thread(c);
		t1.start();
		t2.start();
	}
}
```

-----

#### 1.9 同步函数的锁是 `this`

函数需要被对象调用，那么函数都有一个所属对象引用，就是 `this`。
所以同步函数使用的锁是 `this`。

通过程序来验证。

	使用两个线程来买票。
	一个线程在同步代码块中，
	另一个在同步函数中，
	都在执行买票动作。

(11/ThisLockDemoA)

```java
class Ticket implements Runnable
{
	private int ticks = 10000;

	public boolean flag = true;

	public void run()
	{
		if(flag)
		{
			while(true)
			{
				synchronized(this)
				{
					if(ticks > 0)
					{
						String name = Thread.currentThread().getName();
						System.out.println(name+" code."+ticks);
						ticks--;
					}
				}
				if(ticks == 0)
				{
					return;
				}
			}
		}
		else
		{
			while(true)
			{
				this.sell();
				if(ticks == 0)
				{
					return;
				}
			}
		}
	}
	public synchronized void sell()
	{
		if(ticks > 0)
		{
			String name = Thread.currentThread().getName();
			System.out.println(name+" sell(). "+ticks);
			ticks--;
		}
	}
}

class ThisLockDemoA
{
	public static void main(String[] args)
	{
		Ticket t = new Ticket();

		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);

		t1.start();
		try
		{
			Thread.sleep(10);
		}
		catch(Exception e)
		{

		}
		t.flag = false;
		t2.start();
	}
}
```

----------------------------

#### 1.10 静态同步函数的锁是Class对象

如果同步函数被 `static` 静态修饰后，使用的锁是什么呢？

通过验证发现不是 `this`。因为静态方法中也不可以定义 `this`.

静态进入内存时，内存没有本类实例对象，但是一定有该类对应的字节码文件对象。类名.class，该对象的类型是 `Class`.

静态的同步方法，使用的锁是该方法所在类的字节码文件对象。类名.class

(11/StaticMethodDemoA)

```java
class Ticket implements Runnable
{
	private static int ticks = 10000;

	public boolean flag = true;

	public void run()
	{
		if(flag)
		{
			while(true)
			{
				synchronized(Ticket.class)
				{
					if(ticks > 0)
					{
						String name = Thread.currentThread().getName();
						System.out.println(name+" code."+ticks);
						ticks--;
					}
				}
				if(ticks == 0)
				{
					return;
				}
			}
		}
		else
		{
			while(true)
			{
				this.sell();
				if(ticks == 0)
				{
					return;
				}
			}
		}
	}
	public static synchronized void sell()
	{
		if(ticks > 0)
		{
			String name = Thread.currentThread().getName();
			System.out.println(name+" sell(). "+ticks);
			ticks--;
		}
	}
}

class StaticMethodDemoA
{
	public static void main(String[] args)
	{
		Ticket t = new Ticket();

		Thread t1 = new Thread(t);
		Thread t2 = new Thread(t);

		t1.start();
		try
		{
			Thread.sleep(10);
		}
		catch(Exception e)
		{

		}
		t.flag = false;
		t2.start();
	}
}
```

#### 1.11 多线程----死锁

(11/DeadLockDemoA)

```java
class Test implements Runnable
{
	private boolean flag;

	Test(boolean flag)
	{
		this.flag = flag;
	}

	public void run()
	{
		if(flag)
		{
			synchronized (MyLock.a)
			{	
				System.out.println(Thread.currentThread().getName()+" if Mylock.a");
				synchronized(MyLock.b)
				{
					System.out.println(Thread.currentThread().getName()+" if Mylock.b");
				}
			}
		}
		else
		{
			synchronized (MyLock.b)
			{	
				System.out.println(Thread.currentThread().getName()+" else Mylock.b");
				synchronized(MyLock.a)
				{
					System.out.println(Thread.currentThread().getName()+ " else Mylock.a");
				}
			}
		}
	}
}

class MyLock
{
	public static Object a = new Object();
	public static Object b = new Object();
}

class DeadLockDemoA
{
	public static void main(String[] args)
	{
		Thread a = new Thread(new Test(true));
		Thread b = new Thread(new Test(false));
		a.start();
		b.start();
	}
}
```
**运行结果**
	
	Thread-0 if Mylock.a
	Thread-1 else Mylock.b
	
	或

	Thread-1 else Mylock.b
	Thread-0 if Mylock.a

**代码分析**

	预想代码执行结果应该是
	Thread-0 if Mylock.a
	Thread-0 if Mylock.b
	Thread-1 else Mylock.b
	Thread-1 else Mylock.a

	或

	Thread-1 else Mylock.a
	Thread-1 else Mylock.b
	Thread-0 if Mylock.a
	Thread-0 if Mylock.b

	出现原因，if代码块中和else代码块中，公用了MyLock.a和MyLock.b，
	如果if代码块打印了Thread-0 if MyLock.a后，
	进入了临时状态（此刻，if代码块持有MyLock.a，同步代码块没运行完，MylLock.a 未被释放）；
	这时else代码块执行，打印Thread-1 else MyLock.b，
	由于MyLock.a还在if代码块手上，导致不能完成同步代码块else MyLock.a 的执行；
	最终导致if代码块和else代码块各自握着一个未能被释放的锁。
	所以程序处于死锁状态。

----------------------------

### 2 多线程进阶

#### 2.1 多线程间的通信

(12/InputOutputDemoA)

```java
class Resource
{
	String name;
	String sex;
}

class Input implements Runnable
{
	private Resource r;
	Input(Resource r)
	{
		this.r = r;
	}
	public void run()
	{
		int x = 1;
		while(true)
		{
			synchronized(r)
			{
				if(x == 1)
				{
					r.name = "Mike";
					r.sex = "max";
				}
				else
				{
					r.name = "1111";
					r.sex = "2222";
				}
				x = (x+1)%2;
			}
		}
	}
}

class OutInput implements Runnable
{
	private Resource r;
	OutInput(Resource r)
	{
		this.r = r;
	}
	public void run()
	{
		while(true)
		{
			synchronized(r)
			{
				System.out.println(r.name+"...."+r.sex);
			}
		}
	}
}

class InputOutputDemoA
{
	public static void main(String[] args)
	{
		Resource r = new Resource();

		Input in = new Input(r);
		OutInput out = new OutInput(r);

		Thread t1 = new Thread(in);
		Thread t2 = new Thread(out);

		t1.start();
		t2.start();
	}
}
```

----------------------------

#### 2.2 解决安全问题

----------------------------

#### 2.3 等待唤醒机制 `wait()`，`notify()`，`notifyAll()`

`wait()`，`notify()`，`notifyAll()` 都使用在同步中，因为要对持有监视器（锁）的线程操作。
所以要使用在同步中，因为只有同步才具有锁。

**为什么这些操作线程的方法要定义在 `Object` 类中呢？**

	因为这些方法在操作同步中线程是，都必须要标识它们锁操作线程只有的锁，
	只有同一个锁上的被等待线程，可以被同一个锁上 `notify` 唤醒。
	不可以对不同锁中的线程进行唤醒，也就是锁，等待和唤醒必须是同一个锁。
	而锁可以是任意对象，所以可以被任意对象调用的方法定义在 `Object` 类中。
	（这里要注意的是，多个线程可以共用一个锁。即一个锁上可有多个线程。）

(12/InputOutputDemoB)

```java
class Resource
{
	String name;
	String sex;
	boolean flag;
}

class Input implements Runnable
{
	private Resource r;
	Input(Resource r)
	{
		this.r = r;
	}

	public void run()
	{
		int x = 1;
		while(true)
		{
			synchronized(r)
			{
				if(r.flag)
				{
					try
					{
						r.wait();
					}
					catch(Exception e)
					{

					}
				}
				if(x == 1)
				{
					r.name = "Mike";
					r.sex = "Man";
				}
				else
				{
					r.name = "111111";
					r.sex = "22222";
				}
				x = (x+1)%2;

				r.flag = true;
				r.notify();
			}
		}
	}
}

class Output implements Runnable
{
	private Resource r;
	Output(Resource r)
	{
		this.r = r;
	}

	public void run()
	{
		while(true)
		{
			synchronized(r)
			{
				if(!r.flag)
				{
					try
					{
						r.wait();
					}
					catch(Exception e)
					{
						
					}
				}
				System.out.println(r.name+"..."+r.sex);

				r.flag = false;
				r.notify();
			}
		}
	}
}

class InputOutputDemoB
{
	public static void main(String[] args)
	{
		Resource r = new Resource();

		Input in = new Input(r);
		Output out = new Output(r);

		Thread t1 = new Thread(in);
		Thread t2 = new Thread(out);

		t1.start();
		t2.start();
	}
}
```

----------------------------

#### 2.4 等待唤醒----代码优化

(12/InputOutputDemoC)

class Resource
{
	private String name;
	private String sex;
	private boolean flag = false;

	public synchronized void set(String name, String sex)
	{
		if(this.flag)
		{
			try
			{
				this.wait();
			}
			catch(Exception e)
			{

			}
		}

		this.name = name;
		this.sex = sex;

		this.flag = true;
		this.notify();
	}

	public synchronized void get()
	{
		if(!this.flag)
		{
			try
			{
				this.wait();
			}
			catch(Exception e)
			{

			}
		}
		System.out.println(this.name+"..."+this.sex);

		this.flag = false;
		this.notify();
	}
}

class Input implements Runnable
{
	private Resource r;
	Input(Resource r)
	{
		this.r = r;
	}

	public void run()
	{
		int x = 1;
		while(true)
		{
			if(x == 1)
			{
				r.set("Nike", "Man");
			}
			else
			{
				r.set("1111", "222");
			}
			x = (x+1)%2;
		}
	}
}

class Output implements Runnable
{
	private Resource r;
	Output(Resource r)
	{
		this.r = r;
	}

	public void run()
	{
		while(true)
		{
			r.get();
		}
	}
}

class InputOutputDemoC
{
	public static void main(String[] args)
	{
		Resource r = new Resource();

		new Thread(new Input(r)).start();
		new Thread(new Output(r)).start();
	}
}

----------------------------

#### 2.5 生产者消费者

**线程挂起（wait）后，不会继续往下执行该线程方法中的代码**

##### 2.5.1 while(true), notifyAll();

(12/ProducerConsumerDemoA)

```java
class Resource
{
	private String name;
	private int count;
	private boolean flag = true;

	public synchronized void set(String name)
	{
		while(flag)
		{
			try
			{
				this.wait();
			}
			catch(Exception e)
			{

			}
		}
		this.name = name + "--" + count++;
		
		System.out.println(Thread.currentThread().getName()+".Producer."+this.name);
		flag = true;
		this.notifyAll();
	}

	public synchronized void get()
	{
		while(!flag)
		{
			try
			{
				this.wait();
			}
			catch(Exception e)
			{

			}
		}

		System.out.println(Thread.currentThread().getName()+"..Consumer.."+this.name);
		flag = false;
		this.notifyAll();
	}
}

class Producer implements Runnable
{
	private Resource res;

	Producer(Resource r)
	{
		this.res = r;
	}
	public void run()
	{
		while(true)
		{
			res.set("+SHOP+");
		}
	}
}

class Consumer implements Runnable
{
	private Resource res;

	Consumer(Resource r)
	{
		this.res = r;
	}
	public void run()
	{
		while(true)
		{
			res.get();
		}
	}
}

class ProducerConsumerDemoA
{
	public static void main(String[] args)
	{
		Resource r = new Resource();

		Producer p = new Producer(r);
		Consumer c = new Consumer(r);

		Thread t1 = new Thread(p);
		Thread t2 = new Thread(p);
		Thread t3 = new Thread(c);
		Thread t4 = new Thread(c);

		t1.start();
		t2.start();
		t3.start();
		t4.start();
	}
}
```

对于多个生产者和消费者。
**为什么要定义while判断标记。**

	原因：让被唤醒的线程再一次判断标记。

**为什么定义 `notifyAll` ？**
	
	因为需要唤醒对方线程。
	因为只用notify，容易出现只唤醒本方线程的情况。
	导致程序中的所有线程都等待

----------------------------

##### 2.5.2 Lock对象

JDK1.5 中提供了多线程升级解决方案。
将同步 `Synchronized` 替换成显式 `Lock` 操作。
将 `Object` 中的 `wait`, `notify` 和 `notifyAll`，替换成 `Condition` 对象。
该对象可以从 `Lock` 进行获取。
在该示例中，实现了本方只唤醒对方操作。

(12/ProducerConsumerDemoB)

```java
import java.util.concurrent.locks.*;

class Resource
{
	private String name;
	private int count;
	private boolean flag = false;

	private Lock lock = new ReentrantLock();

	private Condition condition_pro = lock.newCondition();
	private Condition condition_con = lock.newCondition();

	public void set(String name) throws InterruptedException
	{
		lock.lock();

		try
		{
			while(flag)
			{
				condition_pro.await();
			}
			this.name = name + "--" + count++;

			System.out.println(Thread.currentThread().getName()+"...Producer."+this.name);
			
			flag = true;
			condition_con.signalAll();
		}
		finally
		{
			lock.unlock();
		}
	}

	public void get() throws InterruptedException
	{
		lock.lock();

		try
		{
			while(!flag)
			{
				condition_con.await();
			}
			System.out.println(Thread.currentThread().getName()+".Consumer."+this.name);

			flag = false;
			condition_pro.signalAll();
		}
		finally
		{
			lock.unlock();
		}
	}
}

class Producer implements Runnable
{
	private Resource r;
	Producer(Resource r)
	{
		this.r = r;
	}

	public void run()
	{
		while(true)
		{
			try
			{
				r.set("Goods");
			}
			catch(Exception e)
			{
				
			}
		}
	}
}

class Consumer implements Runnable
{
	private Resource r;
	Consumer(Resource r)
	{
		this.r = r;
	}

	public void run()
	{
		while(true)
		{
			try
			{
				r.get();
			}
			catch(Exception e)
			{

			}
		}
	}
}

class ProducerConsumerDemoB
{
	public static void main(String[] args)
	{
		Resource r = new Resource();

		Producer p = new Producer(r);
		Consumer c = new Consumer(r);

		Thread t1 = new Thread(p);
		Thread t2 = new Thread(p);
		Thread t3 = new Thread(c);
		Thread t4 = new Thread(c);

		t1.start();
		t2.start();
		t3.start();
		t4.start();
	}
}
```

----------------------------

#### 2.6 停止线程 `interrupt()`

`stop` 方法已经过时

如何停止线程？
只有一种，让 `run` 方法结束。
开启多线程运行，运行代码通常是循环结构。

只要控制住循环，就可以让 `run` 方法借宿，也就是线程结束。

特殊情况：
当线程处于了冻结状态。
就不会读取到标记，那么线程就不会结束。

当没有指定的方式让冻结的线程回复到运行状态时，这时需要对冻结进行清除。
强制让线程恢复到运行状态中来。这样就可以操作标记让线程结束。

`Thread` 类提供了该方法 `interrupt()`;

(11/StopThreadDemoA)

```java
class StopThread implements Runnable
{
	private boolean flag = true;
	public synchronized void run()
	{
		while(flag)
		{
			try
			{
				this.wait();
			}
			catch(InterruptedException e)
			{
				System.out.println(Thread.currentThread().getName()+"...Exception");
				flag = false;
			}
			System.out.println(Thread.currentThread().getName()+".run");
		}
	}
}

class StopThreadDemoA
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();

		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);

		t1.start();
		t2.start();

		int num = 0;

		while(true)
		{
			if(num++ == 60)
			{
				t1.interrupt();
				t2.interrupt();
				break;
			}
			System.out.println(Thread.currentThread().getName()+"....."+num);
		}
		System.out.println("over");
	}
}
```

----------------------------

#### 2.7 守护线程（后台线程）`setDaemon()`

守护线程（后台线程）：当所有前台线程都结束后，会自动结束后台线程。

(12/SetDaemonDemoA)

```java
class StopThread implements Runnable
{
	private boolean flag = true;

	public synchronized  void run()
	{
		while(flag)
		{
			try
			{
				this.wait();
			}
			catch(Exception e)
			{
				System.out.println(Thread.currentThread().getName()+"..Exception");
			}
			System.out.println(Thread.currentThread().getName()+".run");
		}
	}
}

class SetDaemonDemoA
{
	public static void main(String[] args)
	{
		StopThread st = new StopThread();

		Thread t1 = new Thread(st);
		Thread t2 = new Thread(st);

		t1.setDaemon(true);
		t2.setDaemon(true);
		t1.start();
		t2.start();

		int num = 0;

		while(true)
		{
			if(num++ == 60)
			{
				break;
			}
			System.out.println(Thread.currentThread().getName()+"--"+num);
		}
		System.out.println("over");
	}
}
```

中断线程 `t1.interrupt()` 和 `t1.setDaemon()` 的特点

	共同点：
		都可以结束线程。
	区别：
		interrupt()是将处在wait()状态中的线程激活，
		让其执行完该线程wait()处之后的代码。
		setDaemon()是直接退出线程，
		不会再执行该线程wait()处只会的代码。

----------------------------

#### 2.8 join()

join():

当A线程执行到B线程的.join()方法时，A就会等待，等到B线程执行完，A线程才会继续执行。
join可以用来临时加入线程执行。

(12/JoinDemoA)

```java
class Demo implements Runnable
{
	public void run()
	{
		for(int x = 0; x < 70; x++)
		{
			String threadName = Thread.currentThread().getName();
			System.out.println(threadName+"..."+x);
		}
	}
}

class JoinDemoA
{
	public static void main(String[] args) throws Exception
	{
		Demo d = new Demo();

		Thread t1 = new Thread(d);
		Thread t2 = new Thread(d);

		t1.start();
		t1.join();

		t2.start();

		for(int x = 0; x < 33; x++)
		{
			String threadName = Thread.currentThread().getName();
			System.out.println(threadName+"---"+x);
		}
	}
}
```

----------------------------

#### 2.9 线程其他方法 

##### 2.9.1 `toString()`

(12/ThreadToString)

```java
class Demo implements Runnable
{
	public void run()
	{
		for(int x = 0; x < 70; x++)
		{
			String threadName = Thread.currentThread().toString();
			System.out.println(threadName+"..."+x);
		}
	}
}

class ThreadToString
{
	public static void main(String[] args) throws Exception
	{
		Demo d = new Demo();

		Thread t1 = new Thread(d);
		Thread t2 = new Thread(d);

		t1.start();
		t1.join();

		t2.start();

		for(int x = 0; x < 33; x++)
		{
			String threadName = Thread.currentThread().getName();
			System.out.println(threadName+"---"+x);
		}
	}
}
```

##### 2.9.2 `SetPriority()`

(12/SetPriority)

Thread.MIN_PRIORITY : 1
Thread.MAX_PRIORITY : 10
Thread.NORM_PRIORITY : 5

```java
class Demo implements Runnable
{
	public void run()
	{
		for(int x = 0; x < 70; x++)
		{
			String threadName = Thread.currentThread().toString();
			System.out.println(threadName+"..."+x);
		}
	}
}

class SetPriority
{
	public static void main(String[] args) throws Exception
	{
		Demo d = new Demo();

		Thread t1 = new Thread(d);
		Thread t2 = new Thread(d);

		t1.start();
		t1.setPriority(Thread.MAX_PRIORITY);

		t2.start();

		for(int x = 0; x < 33; x++)
		{
			String threadName = Thread.currentThread().getName();
			System.out.println(threadName+"---"+x);
		}
	}
}
```

##### 2.9.3 `Yield()`

(12/YieldDemo)

```java
class Demo implements Runnable
{
	public void run()
	{
		for(int x = 0; x < 70; x++)
		{
			String threadName = Thread.currentThread().toString();
			System.out.println(threadName+"..."+x);
			Thread.yield();
		}
	}
}

class YieldDemo
{
	public static void main(String[] args) throws Exception
	{
		Demo d = new Demo();

		Thread t1 = new Thread(d);
		Thread t2 = new Thread(d);

		t1.start();
		t1.setPriority(Thread.MAX_PRIORITY);

		t2.start();

		for(int x = 0; x < 33; x++)
		{
			String threadName = Thread.currentThread().getName();
			// System.out.println(threadName+"---"+x);
		}
	}
}
```

#### 2.10 开发中的多线程

(11/ThreadTest)

```java
class ThreadTest
{
	public static void main(String[] args)
	{

		new Thread()
		{
			public void run()
			{
				for(int x = 0; x < 200; x++)
				{
					String threadName = Thread.currentThread().getName();
					System.out.println(threadName + "---" + x);
				}
			}
		}.start();

		for(int x = 0; x < 100; x++)
		{
			String threadName = Thread.currentThread().getName();

			System.out.println(threadName + "--x");
		}
		
		Runnable r = new Runnable()
		{
			public void run()
			{
				for(int x = 0; x < 300; x++)
				{
					String threadName = Thread.currentThread().getName();
					System.out.println(threadName + "----" + x);
				}
			}
		};
		Thread t = new Thread(r);
		t.start();
	}
}
```



































----------------------------


----------------------------

## `public` `protected` `default` `private` 权限等级

|                  |  public  | protected  |  default  |  private  |
|  --------------- | -------- |  --------  |  -------  |  -------  |
| 同一个类中       |    ok    |     ok     |    ok     |     ok    |
| 同一个包中不同类 |    ok    |     ok     |    ok     |  -------  |
| 不同包的子类     |    ok    |     ok     |  -------  |  -------  |
| 不同包中         |    ok    |  --------  |  -------  |  -------  |


----------------------------


----------------------------

## 设计模式
设计模式：解决某一类问题最行之有效的方法。

### 1.单例

要保证对象唯一：
1.为了避免让其他程序过多建立该对象。先禁止其他程序建立该类对象。
2.还为了让其他程序可以访问到该类对象，只好在本类中，自定义一个对象。
3.为了方便其他程序对自定义对象的访问，可以在对外提供一些访问方式。

这三步怎么用代码体现呢？（类名`ClassName`）
1.将构造函数私有化。

```java
private ClassName(){};
```

2.在类中创建一个本类对象。

```java
private static ClassName c = new ClassName();
```

3.提供一个方法可以获取到该对象。

```java
public static ClassName getInstance()
{
	return c;
}
```

对于事物该怎么描述，还是怎么描述。
当需要将该事物的对象保证在内存中唯一时，就将以上的三步加上即可。

(06/SingleDemoA)

```java
class Student
{
	private int age;
	private String name;

	public void setName(String name)
	{
		this.name = name;
	}

	public String getName()
	{
		return this.name;
	}

	public void setAge(int age)
	{
		this.age = age;
	}

	public int getAge()
	{
		return this.age;
	}

	private Student()
	{

	}

	private static Student c = new Student();

	public static Student getInstance()
	{
		return c;
	}
}

class SingleDemoA
{
	public static void main(String[] args)
	{
		Student s1 = Student.getInstance();

		s1.setName("lili");
		s1.setAge(52);

		System.out.println(s1.getName()+"...."+s1.getAge());	//lili....52

		Student s2 = Student.getInstance();

		System.out.println(s2.getName()+"...."+s2.getAge());	//lili....52
	}
}
```

懒汉式（多线程）

(11/SingleDemoC)

```java
class Single
{
	private String name = "SingleAA";
	private Single()
	{

	};

	public String getName()
	{
		return this.name;
	}

	private static Single s = null;

	public static Single getInstance()
	{
		if(s == null)
		{
			synchronized(Single.class)
			{
				if(s == null)
				{
					s = new Single();
				}
			}
		}
		return s;
	}
}

class SingleDemoAA
{
	public static void main(String[] args)
	{
		Single s = Single.getInstance();
		System.out.println(s.getName());
	}
}
```

(06/SingleDemoB)

```java
//饿汉式：先初始化对象。
//SingleA类一进内存，就已经创建好了对象
class SingleA
{
	private SingleA()
	{

	}
	private static SingleA c = new SingleA();

	public static SingleA getInstance()
	{
		return c;
	}
}

//懒汉式：对象是方法被调用时，才初始化，也叫做对象的延时加载。
//SingleB类进内存，对象还没有存在，只有调用了getInstance方法时，才建立对象。

class SingleB
{
	private SingleB()
	{

	}

	private static SingleB c = null;

	public static SingleB getInstance()
	{
		if (c==null)
		{
			c = new SingleB();
		}
		return c;
	}
}
```

----------------------------

### 2. 模板方法

当一定功能时，功能的一部份是确定的，但是有一部分功能是不确定的，而确定的部分在使用不确定的部分，那么这时就将不确定的部分暴露出去，由该类的子类去完成。

(07/TemplateDemo)

```java
abstract class GetTime
{
	public final void getTime()
	{
		long start = System.currentTimeMillis();
		runCode();
		long end = System.currentTimeMillis();
		System.out.println("Milliseconds:" + (end - start));
	}

	public abstract void runCode();
}

class SubTime extends GetTime
{
	public void runCode()
	{
		int y = 0;
		for(int x = 0; x < 40000; x++)
		{
			y += x;
			y--;
			// System.out.print(x);
		}
		System.out.println("Y:" + y);
	}
}

class TemplateDemoA
{
	public static void main(String[] args)
	{
		SubTime s1 = new SubTime();
		s1.getTime();
	}
}
```