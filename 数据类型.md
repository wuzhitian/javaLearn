[TOC]

## 数据操作API

### 1. String

#### 1.1 概述

(13/StringDemoA)

```java
class StringDemoA
{
	public static void main(String[] args)
	{
		String s1 = "abc";
		String s2 = new String("abc");

		System.out.println(s1 == s2);	    //false!!!!!跟Javascript不一样
		System.out.println(s1.equals(s2));	//true

		String s3 = "abc";
		System.out.println(s1 == s3);	    //true
	}
}
```

`Object.equals()` 方法原是用于比较对象内存地址是否相等的，
在String类中，复写了该方法，用于判断字符串是否相同

----------------------------

#### 1.2 字符串常用方法

##### 1.2.1 获取

* int length();
* char charAt(int index);
* int indexOf();
	* int indexOf(int ch);	//ch ASCII 编码
	* int indexOf(int ch, int fromIndex);
	* int indexOf(String str);
	* int indexOf(String str, int fromIndex);
* int lastIndexOf();
	* int lastIndexOf(int ch);
	* int lastIndexOf(int ch, int fromIndex);
	* int lastIndexOf(String str);
	* int lastIndexOf(String str, int fromIndex);

(13/StringMethodDemoA)

```java
class StringMethodDemoA
{
	public static void main(String[] args)
	{
		get();
	}

	public static void get()
	{
		String str = "abcdefgacd";

		sop(str.length());				//10
		sop(str.indexOf(97));			//0
		sop(str.indexOf(97, 3));		//7
		sop(str.indexOf("a"));			//0
		sop(str.indexOf("a", 2));		//7
		sop(str.lastIndexOf("a"));		//7
		sop(str.lastIndexOf("a", 3));	//0

		sop((char)65);		//A
		sop((int)'a');		//97
		sop((byte)'a');		//97
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 1.2.3 判断

* boolean startsWith(String str);
* boolean endsWith(String str);
* boolean isEmpty();
* boolean contains(CharSequence s);
* boolean equals();
* boolean equalsIgnoreCase();

(13/StringMethodDemoB)

```java
class StringMethodDemoB
{
	public static void main(String[] args)
	{
		is();
	}

	public static void is()
	{
		String str = "abcAbc.java.txt";
		sop(str.startsWith("abc"));			//true
		sop(str.endsWith("txt"));			//true
		sop(str.contains(".java"));			//true
		sop(str.isEmpty());					//false

		String str1 = "abcabc.java.txt";
		sop(str1.equals(str));				//false
		sop(str1.equalsIgnoreCase(str));	//true
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 1.2.3 转换

* 将字符数组转成字符串：
	* 构造函数：
		* String(char[] data);
		* String(char[] data, int offset, int count); //将字符数组中的一部分转成字符串
	* 静态方法：
		* static String copyValueOf(char[] data);
		* static String copyValueOf(char[] data, int offset, int count);
		* static String valueOf(char[] data);
* 将字节数组转成字符串：
	* String(byte[] data);
	* String(byte[] data, int offset, int count);	//将字节数组中的一部分转成字符串。
* 将字符串转成字符数组：
	* char[] toCharArray();
* 将字符串转成字节数组：
	* byte[] getBytes();
* 将基本数据类型转成字符串：
	* static String valueOf(int num);
	* static String valueOf(double num);

(13/StringMethodDemoC)

```java
class StringMethodDemoC
{

	public static void transform()
	{
		char[] a = {'a', 'd', 'c', 'f', 'g'};

		String str1 = new String(a);
		sop(str1);				//"adcfg"

		String str2 = new String(a, 2, 3);
		sop(str2);				//"cfg"

		String str3 = String.copyValueOf(a);
		sop(str3);				//"adcfg"

		String str4 = String.copyValueOf(a, 2, 3);
		sop(str4);				//"cfg"

		String str5 = String.valueOf(a);
		sop(str5);				//"adcfg"



		byte[] b = {97, 98, 99, 100, 101, 102};

		String str6 = new String(b);
		sop(str6);				//"abcdef"

		String str7 = new String(b, 2, 3);
		sop(str7);				//"cde"

		
		String s = "GHIJK";

		char[] c1 = s.toCharArray();
		for(int x = 0; x < c1.length; x++)
		{
			System.out.print("c1["+x+"]:"+c1[x]+" | ");
			//c1[0]:G | c1[1]:H | c1[2]:I | c1[3]:J | c1[4]:K | 
		}
		System.out.println("");


		byte[] b1 = s.getBytes();
		for(int x = 0; x < b1.length; x++)
		{
			System.out.print("b1["+x+"]:"+b1[x]+" | ");
			//b1[0]:71 | b1[1]:72 | b1[2]:73 | b1[3]:74 | b1[4]:75 |
		}
		System.out.println("");


		String str8 = String.valueOf(5678);
		sop(str8);				//"5678"

		String str9 = String.valueOf(34.55444333);
		sop(str9);				//"34.55444333"
	}

	public static void main(String[] args)
	{
		transform();
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 1.2.4 切割和替换

* 替换
	* String replace(char oldChar, char newChar);
	* String replace(CharSequence target, CharSequence replacement);
* 切割
	* String[] split(regEx);
* 子串
	* String substring(int begin);
	* String substring(int begin, int end);

(13/StringMethodDemoD)

```java
class StringMethodDemoD
{
	public static void replace()
	{
		String s = "Hello Java";

		String s1 = s.replace('a', 'n');
		sop(s);			//"Hello Java"
		sop(s1);		//"Hello Jnvn"

		String s2 = s.replace('c', 'n');
		sop(s2);		//"Hello Java"

		String s3 = s.replace("Java", "World");
		sop(s3);		//"Hello World"
	}

	public static void split()
	{
		String s = "Lili, Jack, Mike, Jame";
		String[] s1 = s.split(",");

		for(int x = 0; x < s1.length; x++)
		{
			System.out.print("s1["+x+"]:"+ s1[x] + " |");
			//s1[0]:Lili |s1[1]: Jack |s1[2]: Mike |s1[3]: Jame |
		}
		System.out.println("");
	}

	public static void sub()
	{
		String s = "abcdefghi";

		String s1 = s.substring(3);
		sop(s1);		//"defghi"

		String s2 = s.substring(3, 5);
		sop(s2);		//"de"
	}

	public static void main(String[] args)
	{
		replace();
		split();
		sub();
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 1.2.5 转换，去除空格，比较

* 将字符串转成大写或小写
	* String toLowerCase();
	* String toUpperCase();
* 将字符串两端的多个空格去除
	* String trim();
* 对两个字符串进行自然顺序的比较
	* int compareTo(String str);

**`compareTo()`**
	
	如果参数字符串等于此字符串，则返回值 0；
	如果此字符串按字典顺序小于字符串参数，则返回一个小于 0 的值；
	如果此字符串按字典顺序大于字符串参数，则返回一个大于 0 的值。


(13/StringMethodDemoE)

```java
class StringMethodDemoE
{
	public static void main(String[] args)
	{
		String s = "  Hello  ";

		String s1 = s.toLowerCase();
		sop(s1);		//"  hello  "

		String s2 = s.toUpperCase();
		sop(s2);		//"  HELLO  "

		String s3 = s.trim();
		sop(s3);		//"hello"


		String ss0 = "aac";
		String ss1 = "aac";
		String ss2 = "aec";
		String ss3 = "azd";

		int i0 = ss0.compareTo(ss1);
		sop(i0);			//0

		int i1 = ss1.compareTo(ss2);
		sop(i1);			//-4

		int i2 = ss3.compareTo(ss2);
		sop(i2);			//21

	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

#### 1.3 字符串练习

##### 1.3.1 模拟trim方法

(13/StringExerciseTrimA)

```java
class StringExerciseTrimA
{
	public static void main(String[] args)
	{
		String str = "  ef  g  ";

		String s1 = myTrim(str);
		sop(s1);

		String s2 = myTrimDemo(str);
		sop(s2);
	}

	public static String myTrimDemo(String str)
	{
		int startIndex = 0;
		int endIndex = str.length() - 1;

		while(str.charAt(startIndex) == ' ' &&  startIndex <= endIndex)
		{
			startIndex++;
		}

		while(str.charAt(endIndex) == ' ' && endIndex >= startIndex)
		{
			endIndex--;
		}

		return str.substring(startIndex, endIndex+1);
	}


	public static String myTrim(String str)
	{
		int startIndex = 0;
		for(int x = 0; x < str.length(); x++)
		{
			if(str.charAt(x) != ' ')
			{
				startIndex = x; 
				break;
			}
		}
		String temp0 = str.substring(startIndex);

		int endIndex = temp0.length();
		for(int x = temp0.length()-1; x > 0; x--)
		{
			if(temp0.charAt(x) != ' ')
			{
				endIndex = x;
				break;
			}
		}
		String temp1 = temp0.substring(0, endIndex+1);
		
		return temp1;

	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 1.3.2 字符串反转

(13/StringExerciseReverseA)

```java
class StringExerciseReverseA
{
	public static void main(String[] args)
	{
		String str = "abcdefg";
		String str1 = reverseA(str);

		sop(str1);

		String str2 = reverseB(str, 2, 16);
		sop(str2);



		String sss = "abcd  efgh";
		sop(reverseString(sss));
		sop(reverseString(sss, 4, 7));
	}

	//**********Demo code********//
	
	public static String reverseString(String str)
	{
		return reverseString(str, 0, str.length());
	}

	
	public static String reverseString(String str, int startIndex, int endIndex)
	{
		char[] c = str.toCharArray();

		reverse(c, startIndex, endIndex);

		return new String(c);
	}

	public static void reverse(char[] c, int startIndex, int endIndex)
	{
		for(int start = 0, end = endIndex - 1; start < end; start++, end--)
		{
			swap(c, start, end);
		}
	}
	public static void swap(char[] c, int x, int y)
	{
		char temp = c[x];
		c[x] = c[y];
		c[y] = temp;
	}


	//***************************//





	public static String reverseA(String str)
	{
		char[] c = str.toCharArray();
		char[] c1 = new char[c.length];

		for(int x = 0; x < c.length; x++)
		{
			c1[x] = c[c.length-1-x];
		}

		return new String(c1);
	}

	public static String reverseB(String str, int startIndex, int endIndex)
	{

		try
		{
			if(startIndex < str.length() && endIndex < str.length())
			{
				String c0 = str.substring(0, startIndex);
				String c1 = str.substring(startIndex, endIndex);
				String c2 = str.substring(endIndex, str.length());
				return c0+reverseA(c1)+c2;
			}
			else
			{
				throw new Exception();
			}
		}
		catch(Exception e)
		{
			sop(e);
		}
		return str;
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 1.3.3 获取字符出现次数

(13/StringExerciseCountA)

```java
class StringExerciseCountA
{
	public static void main(String[] args)
	{
		String ss = "aabbccdfgdeeccfg ";
		sop(ss.split("fg").length);
		sop(countA(ss, "cc"));

		sop(countDemoA(ss, "e"));
		sop(countDemoB(ss, "e"));
	}

	//**********Demo Code*********//
	public static int countDemoA(String str, String subStr)
	{
		int count = 0;
		int index = 0;

		while((index = str.indexOf(subStr, index)) != -1)	////!!!!
		{
			index = index + subStr.length();
			count++;
		}
		return count;
	}

	public static int countDemoB(String str, String subStr)
	{
		int count = 0;
		int index = 0;

		while((index = str.indexOf(subStr)) != -1)
		{
			str = str.substring(index+subStr.length());
			count++;
		}
		return count++;
	}

	//****************************//


	public static int countA(String str, String subStr)
	{
		if(str.contains(subStr))
		{
			String[] arr = str.split(subStr);
			if(str.endsWith(subStr))
			{
				return arr.length;
			}
			else
			{
				return arr.length - 1;
			}
		}
		else
		{
			return -1;
		}
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 1.3.4 获取两个字符串中最大相同子串

(13/StringExerciseSameMaxA)

```java
class StringExerciseSameMaxA
{

	public static void main(String[] args)
	{
		String s1 = "abcccdedfesfdsa";
		String s2 = "dedfses";

		sop(getMaxSubString(s1, s2));
	}

	public static String getMaxSubString(String s1, String s2)
	{
		String max = "", min = "";

		max = (s1.length() > s2.length())? s1 : s2;
		min = (max == s1) ? s2 : s1;

		for(int x = 0; x < min.length(); x++)
		{
			for(int y = 0, z = min.length()-x; z != min.length()+1; y++, z++)
			{
				String temp = min.substring(y, z);

				if(max.contains(temp))
				{
					return temp;
				}
			}			
		}
		return "";
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

#### 1.4 StringBuffer

StringBuffer 是字符串缓冲区。
是一个容器。
**特点：**

	1. 可编辑而且长度可变；
	2. 可以操作多种数据类型；
	3. 最终会通过 `toString()` 方法变成字符串。


##### 1.4.1 常见功能

###### 1.4.1.1 存储

	* StringBuffer append();
	* StringBuffer insert();

(13/StringBufferDemoA)

```java
class StringBufferDemoA
{
	public static void main(String[] args)
	{
		StringBuffer sb = new StringBuffer();
		sb.append("321").append(true).append("ddd");

		sop(sb);				//321trueddd

		sb.insert(1, "uuuu");
		sop(sb);				//3uuuu21trueddd
		sop(sb.toString());		//3uuuu21trueddd
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

###### 1.4.2 删除

* StringBuffer delete(start, end);
* StringBuffer deleteCharAt(index): 删除指定位置字符

(13/StringBufferDemoB)

```java
class StringBufferDemoB
{
	public static void main(String[] args)
	{
		StringBuffer sb = new StringBuffer("abcde");

		sop(sb.toString());		//abcde;

		sop(sb.delete(2, 4));	//abe;

		sop(sb.deleteCharAt(1));	//ae;

	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

###### 1.4.3 获取

* char charAt(int index);
* int indexOf(String str);
* int lastIndexOf(String str);
* int length();
* StringBuffer substring(int start, int end);

(13/StringBufferDemoC)

```java
class StringBufferDemoC
{
	public static void main(String[] args)
	{
		StringBuffer ss = new StringBuffer("abcdefghiejk");

		sop(ss.charAt(4));			//e
		sop(ss.indexOf("e"));		//4
		sop(ss.lastIndexOf("e"));	//9
		sop(ss.length());			//12
		sop(ss.substring(2, 6));	//cdef
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

###### 1.4.4 修改

* StringBuffer replace(int start, int end, String str);
* void setCharAt(int index, char ch);

(13/StringBufferDemoD)

```java
class StringBufferDemoD
{
	public static void main(String[] args)
	{
		StringBuffer ss = new StringBuffer("abcdefghijk");
		sop(ss.replace(3, 5, "pppp"));	//abcppppfghijk

		ss.setCharAt(8, 'Y');
		sop(ss);						//abcppppfYhijk
	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

###### 1.4.5 翻转

* StringBuffer reverse();

(13/StringBufferDemoE)

```java
class StringBufferDemoE
{
	public static void main(String[] args)
	{
		StringBuffer ss = new StringBuffer("abcdefg");

		sop(ss.reverse());		//gfedcba
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

将缓冲区中指定数据存储到指定字符数组中。

	* void getChars(int srcBegin, int srcEnd, char[] dist, int distBegin)


(13/StringBufferDemoF)

```java
class StringBufferDemoF
{
	public static void main(String[] args)
	{
		StringBuffer ss = new StringBuffer("abcdefg");

		char[] ch = new char[5];

		ss.getChars(2, 4, ch, 3);

		for(int x = 0; x < ch.length; x++)
		{
			System.out.println(ch[x]);
			//[ , , ,'c', 'd']
		}
	}
}
```

----------------------------

#### 1.5 StringBuilder

`StringBuffer` 是线程同步的
`StringBuilder` 是线程不同步的

`Java`升级的三个方向：
	
	* 简化书写
	* 提高效率
	* 提高安全性

----------------------------

## 2. 基本数据类型

基本数据类型对象包装类
	
| 基本类型  | 对应对象    |
|-----------|-------------|
|   byte    |   Byte      |
|   short   |   Short     |
|   int     |   Integer   |
|   long    |   Long      |
|   double  |   Double    |
|   float   |   Float     |
|   boolean |   Boolean   |
|   char    |   Character |

基本数据类型对象包装类的最常见作用：
	
	就是用于基本数据类型和字符串类型之间做转换

基本数据类型转成字符串：

	1. 基本数据类型+"";
		eg: 33+"" 	//"33"
	2. 基本数据类型.toString(基本数据类型);
		eg: Integer.toString(33) 	//"33"

字符串转成基本数据类型：

	1. xxx a = Xxx.parseXxx(String);
		eg: int a = Integer.parseInt("123");	//123
		eg: double b = Double.parseDouble("12.23");	//12.23
		eg: boolean c = Boolean.parseBoolean("true");
		eg: boolean d = Boolean.parseBoolean("false");
		eg: boolean e = Boolean.parseBoolean("");

十进制转成其他进制：

	toBinaryString();
	toHexString();
	toOctalString();

其他进制转成十进制：
	
	parseInt(String str, int radix);

(13/BasicDataDemoA)

```java
class BasicDataDemoA
{
	public static void main(String[] args)
	{
		sop(Integer.MAX_VALUE);				//	2147483647
		sop(Integer.MIN_VALUE);				//	-2147483648
		sop(Integer.TYPE);					//	int
		sop(Integer.SIZE);					//	32
		sop(Integer.parseInt("432"));		//  432

		sop(Integer.parseInt("110", 2));	//  6
		sop(Integer.parseInt("170", 8));	//  120
		sop(Integer.parseInt("110", 10));	//  110
		sop(Integer.parseInt("1a0", 16));	//  416

		sop(Integer.toBinaryString(6));		//  110
		sop(Integer.toHexString(699));		//  2bb
		sop(Integer.toOctalString(4432));	//  10520



		sop(Boolean.parseBoolean("true"));	//  true
		sop(Boolean.parseBoolean("tRue"));	//  true
		sop(Boolean.parseBoolean("false"));	//  false
		sop(Boolean.parseBoolean(""));		//  false
		sop(Boolean.parseBoolean("aaa"));	//  false



		sop(Double.parseDouble("122.112"));	//  122.112


		Integer num = new Integer("4432");
		sop(num);					//  4432
		sop(num.intValue());		//  4432
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

(13/BasicDataDemoB)

```java
class BasicDataDemoB
{
	public static void main(String[] args)
	{
		Integer a = new Integer(123);
		Integer b = new Integer(123);
		sop("a.equals(b):" + (a.equals(b)));	//true
		sop("a == b:" + (a == b));				//false


		Integer mm = 128;
		Integer nn = 128;
		sop("mm == nn: " + (mm == nn));	//false


		Integer aa = 127;
		Integer bb = 127;
		sop("aa == bb: "+ (aa == bb));	//true


		Integer xx = 4;
		xx = xx + 4;
		sop(xx);		//8
	}


	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

## 3. 集合类 Collection

	Collection
		|-- List: 元素是有序的，元素可以重复。因为该集合体系有索引。
			  |-- Vector: 底层是数组数据结构。**线程同步**。基本已被ArrayList替代。
			  |-- ArrayList: 底层的数据结构使用的是 **数组** 结构。
			  			特点: 查询速度很快，但是增删稍慢。**线程不同步**。
			  |-- LinkedList: 底层使用的是 **链表** 数据结构。
			  			特点: 增删速度很快，查询稍慢。
		|-- Set: 元素是无序的，元素不能重复。因为该集合体系没有索引。
		      |-- HashSet: 底层数据结构是哈希表。线程是非同步的。
		      			特点: 内部按哈希值大小进行排序
		      |-- TreeSet: 底层数据结构是二叉树。
		      			特点: 可以对Set集合中的元素进行排序。

### 3.1 集合Collection的基本介绍

#### 3.1.1 基本操作方法

* add(Object obj);
* size();
* clear();
* remove();
* isEmpty();
* contains(Object obj);
* retainAll(Collection c);	//获取交集，会改变原集合
* removeAll(Collection c);	//去除交集，会改变原集合

(14/CollectionDemoA)

```java
import java.util.*;

class CollectionDemoA
{
	public static void main(String[] args)
	{
		// methodA();
		methodB();
	}

	public static void methodA()
	{
		ArrayList al1 = new ArrayList();

		al1.add("java01");
		al1.add("java02");
		al1.add("java03");

		sop(al1);						// [java01, java02, java03]
		sop(al1.size());				// 3

		sop(al1.remove("java02"));		// true
		sop(al1.remove("java04"));		// false
		sop(al1);						// [java01, java03]
		sop(al1.contains("java01"));	// true

		al1.clear();
		sop(al1);						// []
		sop(al1.isEmpty());				// true
	}

	public static void methodB()
	{
		ArrayList al1 = new ArrayList();
		al1.add("java1");
		al1.add("java2");
		al1.add("java3");
		al1.add("java4");

		ArrayList al2 = new ArrayList();
		al2.add("java3");
		al2.add("java4");
		al2.add("java5");
		al2.add("java6");

		al1.retainAll(al2);

		sop(al1);						// [java3, java4]
		sop(al2);						// [java3, java4, java5, java6]



		ArrayList al3 = new ArrayList();
		al3.add("java1");
		al3.add("java2");
		al3.add("java3");
		al3.add("java4");

		ArrayList al4 = new ArrayList();
		al4.add("java3");
		al4.add("java4");
		al4.add("java5");
		al4.add("java6");

		al3.removeAll(al4);
		sop(al3);						// [java1, java2]
		sop(al4);						// [java3, java4, java5, java6]



		ArrayList al5 = new ArrayList();
		al5.add("java1");
		al5.add("java2");
		al5.add("java3");
		al5.add("java4");

		ArrayList al6 = new ArrayList();
		al6.add("java3");
		al6.add("java4");
		al6.add("java5");
		al6.add("java6");

		al5.addAll(al6);
		sop(al5);	//[java1, java2, java3, java4, java3, java4, java5, java6]
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

#### 3.1.2 集合迭代器 Iterator 

(14/CollectionDemoB)

```java
import java.util.*;

class CollectionDemoB
{
	public static void main(String[] args)
	{
		ArrayList al1 = new ArrayList();
		al1.add("java1");
		al1.add("java2");
		al1.add("java3");
		al1.add("java4");

		Iterator it = al1.iterator();

		while(it.hasNext())
		{
			sop(it.next());
		}


		sop(it.hasNext());	//false
		al1.add("java5");
		sop(al1);
		sop(it.hasNext());	//true
		// sop(it.next());	//ConcurrentModificationException


		for(Iterator itt = al1.iterator(); itt.hasNext();)
		{
			sop(itt.next());
		}

		// int x = 0;
		// Iterator ittt = al1.iterator();
		// while(x < 5)
		// {
		// 	sop(ittt.next());
		// 	al1.add("java6");
		// 	x++;
		// }

	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

### 3.2 List（有序带索引）
	
	List: 元素是有序的，元素可以重复。因为该集合体系有索引。
		|-- Vector: 底层是数组数据结构。*线程同步*。基本已被ArrayList替代。
		|-- ArrayList: 底层的数据结构使用的是 *数组* 结构。
					特点: 查询速度很快，但是增删稍慢。*线程不同步*。
		|-- LinkedList: 底层使用的是 *链表* 数据结构。
					特点: 增删速度很快，查询稍慢。

#### 3.2.1 List集合的特有方法

凡是可以操作脚标的方法都是该体系特有的方法。

* add(int index, Object obj);
* remove(int index);
* get(int index);
* subList(int startIndex, int endIndex);
* indexOf(Object obj);
* listIterator();

List集合特有的迭代器，ListIterator是Iterator的子接口。

在使用迭代器时，不可以通过**集合对象的方法**操作集合中的元素。
因为会发生 `ConcurrentModificationException` 异常。

所以，在使用迭代器时，只能用**迭代器的方法**操作元素，可是 `Iterator` 方法是有局限性的，只能对元素进行 *判断* ，*取出*，*删除* 的操作。
如果想要其他的操作，如*添加*，*删除* 等，就需要使用其子接口 `ListIterator`.
该接口只能通过List集合的 `listIterator` 方法获取。


(14/ListDemoA)

```java
import java.util.*;

class ListDemoA
{
	public static void main(String[] args)
	{
		methodA();
		methodB();
	}

	public static void methodA()
	{
		ArrayList al = new ArrayList();

		al.add("j01");
		al.add("j02");
		al.add("j03");
		al.add("j04");

		sop(al);		//[j01, j02, j03, j04]

		al.add(1, "java02");

		sop(al);		//[j01, java02, j02, j03, j04]

		al.remove(2);

		sop(al);		//[j01, java02, j03, j04]

		for(int x = 0; x < al.size(); x ++)
		{
			sop(al.get(x));
			// j01
			// java02
			// j03
			// j04
		}

		sop(al.indexOf("j03"));		//2

		List sub = al.subList(2, 4);
		sop(sub);			//[j03, j04]
	}

	public static void methodB()
	{
		ArrayList al = new ArrayList();

		al.add("j01");
		al.add("j02");
		al.add("j03");
		al.add("j04");

		ListIterator lt = al.listIterator();

		while (lt.hasNext())
		{
			if(lt.next().equals("j03"))
			{
				lt.set("jjjjj03");
			}
			if(lt.next().equals("j02"))
			{
				lt.add("ooo09");
			}
		}
		sop(al);	//[j01, j02, ooo09, jjjjj03, j04]

		while(lt.hasPrevious())
		{
			sop(lt.previous());
			// j04
			// jjjjj03
			// ooo09
			// j02
			// j01
		}
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

#### 3.2.2 List集合具体对象的特点
	
	List: 元素是有序的，元素可以重复。因为该集合体系有索引。
		|-- Vector: 底层是数组数据结构。*线程同步*。基本已被ArrayList替代。
		|-- ArrayList: 底层的数据结构使用的是 *数组* 结构。
					特点: 查询速度很快，但是增删稍慢。*线程不同步*。
		|-- LinkedList: 底层使用的是 *链表* 数据结构。
					特点: 增删速度很快，查询稍慢。

----------------------------

#### 3.2.3 Vector

枚举就是 `Vector` 特有的取出方式。
发现枚举和迭代器很像，其实枚举和迭代一样的。

因为枚举的名称以及方法的名称都过长。
所以被迭代器取代了。

(14/VectorDemoA)

```java
import java.util.*;

class VectorDemoA
{
	public static void main(String[] args)
	{
		Vector v = new Vector();
		v.add("java1");
		v.add("java2");
		v.add("java3");
		v.add("java4");

		Enumeration en = v.elements();

		while(en.hasMoreElements())
		{
			System.out.println(en.nextElement());
			// java1
			// java2
			// java3
			// java4
		}
	}
}
```

----------------------------

#### 3.2.4 LinkedList

##### 3.2.4.1 LinkedList 特有方法

JDK1.6 前

* addFirst();
* addLast();
* getFirst();
* getLast();
* removeFirst();
* removeLast();

`get` 方法获取元素，但 **不删除** 元素。如果集合中没有元素，会抛出 `NoSuchElementException` 。
`remove` 方法获取元素，并且 **删除** 元素。如果集合中没有元素，会抛出 `NoSuchElemntException` 。

JDK1.6 后

* offerFirst();
* offerLast();
* peekFirst();
* peekLast();
* pollFirst();
* pollLast();

`peek` 获取元素，但 **不删除** 元素。 如果集合中没有元素，会返回 `null`；
`poll` 获取元素，并 **删除** 元素。如果集合中没有元素，会返回 `null`。

(14/LinkListDemoA)

```java
import java.util.*;

class LinkedListDemoA
{
	public static void main(String[] args)
	{
		LinkedList l = new LinkedList();

		l.offerFirst("java01");
		l.offerFirst("java02");
		l.offerFirst("java03");
		l.offerFirst("java04");

		sop(l);		//[java04, java03, java02, java01]

		sop(l.peekFirst());		//java04
		sop(l.peekFirst());		//java04
		sop(l.peekLast());		//java01

		sop(l.size());

		sop(l.pollFirst());		//java04;
		sop(l.size());
		sop(l.pollFirst());		//java03;

		while(!l.isEmpty())
		{
			sop(l.pollFirst());
			// java02
			// java01
		}
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 3.2.4.2 LinkedList练习

###### 3.2.4.2.1 堆栈 与 队列 的实现

使用LinkedList模拟一个堆栈或者队列数据结构

堆栈：先进后出（杯子）
队列：先进先出（水管）

(14/LinkedListTestB)

```java
import java.util.*; 

interface MyGet
{
	public abstract Object myGet();
}

abstract class MyData implements MyGet
{
	private LinkedList l;

	MyData()
	{
		l = new LinkedList();
	}

	public LinkedList getL()
	{
		return l;
	}

	public void myAdd(Object obj)
	{
		l.offerFirst(obj);
	}

	public boolean isEmpty()
	{
		return l.isEmpty();
	}

}

class Queue extends MyData
{
	Queue()
	{
		super();
	}

	public Object myGet()
	{
		return super.getL().pollLast();
	}
}

class Stack extends MyData
{
	Stack()
	{
		super();
	}

	public Object myGet()
	{
		return super.getL().pollFirst();
	}
}


class LinkedListTestB
{
	public static void main(String[] args)
	{
		Queue qq = new Queue();
		qq.myAdd("java01");
		qq.myAdd("java02");
		qq.myAdd("java03");
		qq.myAdd("java04");

		while(!qq.isEmpty())
		{
			sop(qq.myGet());
			// java01
			// java02
			// java03
			// java04
		}



		Stack ss = new Stack();
		ss.myAdd("JJ01");
		ss.myAdd("JJ02");
		ss.myAdd("JJ03");
		ss.myAdd("JJ04");

		while(!ss.isEmpty())
		{
			sop(ss.myGet());
			// JJ04
			// JJ03
			// JJ02
			// JJ01
		}
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

#### 3.2.5 ArrayList

##### 3.2.5.1 ArrayList练习

###### 3.2.5.1.1 返回元素唯一的ArrayList 的实现

* hasNext();
* next();
* contains();

(14/ArrayListTestA)

```java
import java.util.*;

class ArrayListTestA
{
	public static void main(String[] args)
	{
		ArrayList al = new ArrayList();
		al.add("java01");
		al.add("java02");
		al.add("java01");
		al.add("java03");
		al.add("java03");
		al.add("java02");

		sop(al);		//java01, java02, java01, java03, java03, java02]
		al = singleElementArray(al);
		sop(al);		//[java01, java02, java03]
	}
	public static ArrayList singleElementArray(ArrayList al)
	{
		ArrayList resultAl = new ArrayList();

		Iterator it = al.iterator();

		while(it.hasNext())
		{
			Object obj = it.next();
			if(!resultAl.contains(obj))
			{
				resultAl.add(obj);
			}
		}

		return resultAl;
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

###### 3.2.5.1.2 返回元素唯一的ArrayList 的实现（自定义对象）

`List` 集合判断元素是否相同，依据是元素的 `equals()` 方法。

`contains()` , `remove()` 在执行时，在底层都会调用 `equals()` 方法进行比对，所以在复写 `equals()` 方法是要注意。

Demo中注意`Person` 类内部 `private` 修饰的 `name` 和 `age`，在类中能直接访问到，即使是通过传参形式传进来的。

(14/ArrayListTestB)

```java
import java.util.*;

class Person
{
	private String name;
	private int age;

	Person(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public String getName()
	{
		return this.name;
	}
	public int getAge()
	{
		return this.age;
	}

	public boolean equals(Object obj)
	{
		if(!(obj instanceof Person)){
			return false;
		}

		Person p = (Person)obj;

		System.out.println(this.name+"....."+p.name);
		//这里注意类内部 private 修饰的name和age

		return this.name.equals(p.getName()) && this.age == p.getAge();
		
		// return this.name.equals(p.name) && this.age == p.age;
	}
}
class ArrayListTestB
{
	public static void main(String[] args)
	{
		ArrayList al = new ArrayList();

		al.add(new Person("lili01", 31));
		al.add(new Person("lili02", 32));
		al.add(new Person("lili02", 32));
		al.add(new Person("lili04", 34));
		al.add(new Person("lili04", 34));
		al.add(new Person("lili05", 35));

		al = singleEleArrayList(al);

		Iterator it = al.iterator();
		while(it.hasNext())
		{
			Person p = (Person)it.next();
			sop(p.getName()+"::"+p.getAge());
		}

		sop("remove:::"+al.remove(new Person("lili02", 32)));	//true
		sop("remove:::"+al.remove(new Person("lili03", 32)));	//false
	}

	public static ArrayList singleEleArrayList(ArrayList al)
	{
		ArrayList resultAL = new ArrayList();

		Iterator it = al.iterator();

		while(it.hasNext())
		{
			Person p = (Person)it.next();
			if(!resultAL.contains(p))
			{
				resultAL.add(p);
			}
		}
		return resultAL;
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

### 3.3 Set（无序不带索引）

	Set: 元素是无序的，元素不可以重复。
		|-- HashSet: 底层数据结构是哈希表。线程是非同步的。
		|-- TreeSet: 底层数据结构是二叉树。

`Set` 集合的功能和 `Collection` 是一致的。

#### 3.3.1 HashSet (hashCode(), equals())

HashSet 是如何保证元素唯一性的呢？

	通过两个方法，hashCode和equals来完成。
	如果元素的hashCode值相同，才会判断equals是否为true。
	如果元素的hashCode值不同，不会调用equals。

	注意：对于判断元素是否存在，以及删除等操作，依赖的方法是元素的hashCode和equals方法。


哈希表的内部排序是按照 `哈希值` 大小排列的，所以跟元素的存储顺序无关。

在构建类的过程中，往往要复写`hashCode()`和`equals()`方法用以判断该类的实例是否相同。

(14/HashSetDemoA)

* hashCode();

```java
import java.util.*;

class Demo
{
	public int hashCode()
	{
		return 15;
	}
}

class HashSetDemoA
{
	public static void main(String[] args)
	{
		Demo d1 = new Demo();
		Demo d2 = new Demo();
		sop(d1);	//Demo@f
		sop(d2);	//Demo@f
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 3.3.1.1 HashSet 元素无序性，唯一性

(14/HashSetDemoB)

```java
import java.util.*;

class HashSetDemoB
{
	public static void main(String[] args)
	{
		HashSet hs = new HashSet();
		hs.add("hs01");
		hs.add("hs02");
		hs.add("hs02");
		hs.add("hs03");
		hs.add("hs03");
		hs.add("hs04");
		hs.add("hs05");

		Iterator it = hs.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next());
			// hs05
			// hs01
			// hs02
			// hs03
			// hs04
		}
	}
}
```

##### 3.3.1.2 HashSet 存储自定义对象

需求：

* 往 `hashSet` 集合中存入自定义对象
* 如果 `name` 和 `age` 相同，则为同一人，去除重复元素

(14/HashSetDemoC)

```java
import java.util.*;

class Person
{
	private String name;
	private int age;

	Person(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public String getName()
	{
		return this.name;
	}
	public int getAge()
	{
		return this.age;
	}

	public int hashCode()
	{
		System.out.println(this.name+"...hashCode");
		return this.name.hashCode() + this.age*45;
	}

	public boolean equals(Object obj)
	{
		if(!(obj instanceof Person))
		{
			return false;
		}

		Person p = (Person)obj;

		System.out.println(this.name+"...equals..."+p.name);

		return this.name.equals(p.name) && this.age == p.age;
	}
}



class HashSetDemoC
{
	public static void main(String[] args)
	{
		HashSet hs = new HashSet();
		hs.add(new Person("lili01", 41));
		hs.add(new Person("lili02", 42));
		hs.add(new Person("lili01", 41));
		hs.add(new Person("lili03", 43));
		hs.add(new Person("lili04", 44));

		sop("a3 contains:: " + hs.contains(new Person("lili03", 43)));
		sop("a3 remove:: " + hs.remove(new Person("lili03", 43)));

		Iterator it = hs.iterator();

		while(it.hasNext())
		{
			Person p = (Person)it.next();
			sop(p.getName()+"|||"+p.getAge());
		}
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```
	
#### 3.3.2 TreeSet

需要用 `TreeSet` 存储的自定义对象，必须实现 `Comparable` 接口，通过具体 `compareTo()` 方法定义对象的排序规则，`TreeSet` 根据排序规则对元素进行排序。

记住，排序时，当主要条件相同时，一定判断一下次要条件。

**如果 `compareTo()` 方法返回0，则认为是同一个元素，不会存储该元素。**

当元素自身不具备比较性，或者具备的比较性不是所需要的。
这是需要让容器自身具备比较性。
定义了比较器，将比较器对象作为参数传递给 `TreeSet` 集合的构造函数。

**当同时定义了两种比较方式时，以 比较器 的比较方式为准。

##### 3.3.2.1 TreeSet 特点

集合内部元素按字典序排序。

```java
import java.util.*;

(15/TreeSetDemoA)

class TreeSetDemoA
{
	public static void main(String[] args)
	{
		TreeSet ts = new TreeSet();

		ts.add("abcd");
		ts.add("cdbd");
		ts.add("aaed");
		ts.add("eescd");

		Iterator it = ts.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next());
		}
	}
}
```

##### 3.3.2.2 TreeSet （存储自定义对象 Comparable）

需要用 `TreeSet` 存储的自定义对象，必须实现 `Comparable` 接口，通过具体 `compareTo()` 方法定义对象的排序规则，`TreeSet` 根据排序规则对元素进行排序。

记住，排序时，当主要条件相同时，一定判断一下次要条件。

**如果 `compareTo()` 方法返回0，则认为是同一个元素，不会存储该元素。**

(15/TreeSetDemoB)

```java
import java.util.*;

class Student implements Comparable
{
	private String name;
	private int age;

	Student(String name, int age)
	{
		this.name = name;
		this.age = age;
	}
	public String getName()
	{
		return this.name;
	}
	public int getAge()
	{
		return this.age;
	}

	public int compareTo(Object obj)
	{
		if(!(obj instanceof Student))
		{
			throw new RuntimeException("Obj is not instanceof Student");
		}

		Student s = (Student)obj;

		int result = this.age - s.age;

		if(result == 0)
		{
			return this.name.compareTo(s.name);
		}
		return result;
	}
}


class TreeSetDemoB
{
	public static void main(String[] args)
	{
		TreeSet ts = new TreeSet();
		ts.add(new Student("lili01", 31));
		ts.add(new Student("lili05", 35));
		ts.add(new Student("lilb03", 33));
		ts.add(new Student("lila02", 32));
		ts.add(new Student("lila02", 32));
		ts.add(new Student("lilb03", 33));
		ts.add(new Student("lilb04", 34));

		Iterator it = ts.iterator();
		while(it.hasNext())
		{
			Student s = (Student)it.next();

			sop(s.getName()+"..||.."+s.getAge());
		}
	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

##### 3.3.2.3 TreeSet 的底层数据结构（二叉树）

底层数据结构是二叉树。
保证元素的唯一性的依据：`compareTo` 方法 `return 0`。

`TreeSet` 排序的第一种方式：让元素自身具备比较性。
元素需要实现 `Comparable` 接口，覆盖 `compareTo` 方法。
这种方式也称为元素的自然顺序，或者叫做默认顺序。

内部元素的排列顺序取决于 `cmopareTo` 的返回值。

(15/TreeSetDemoC)

```java
import java.util.*;

class Student implements Comparable
{
	private String name;
	private int age;

	Student(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public String getName()
	{
		return this.name;
	}

	public int getAge()
	{
		return this.age;
	}

	public int compareTo(Object obj)
	{
		// return 1;
		// return 0;
		return -1;
	}
}

class TreeSetDemoC
{
	public static void main(String[] args)
	{
		TreeSet ts = new TreeSet();
		ts.add(new Student("lili023", 33));
		ts.add(new Student("lili021", 31));
		ts.add(new Student("lili023", 33));
		ts.add(new Student("lili020", 30));

		Iterator it = ts.iterator();
		while (it.hasNext())
		{
			Student s = (Student)it.next();

			System.out.println(s.getName()+"......"+s.getAge());
		}

	}
}
```

##### 3.3.2.4 TreeSet （实现Comparator方式排序）

当元素自身不具备比较性，或者具备的比较性不是所需要的。
这是需要让容器自身具备比较性。
定义了比较器，将比较器对象作为参数传递给 `TreeSet` 集合的构造函数。

**当同时定义了两种比较方式时，以 比较器 的比较方式为准。

(15/TreeSetDemoD)

```java
import java.util.*;

class Student implements Comparable
{
	private String name;
	private int age;

	Student(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public String getName()
	{
		return this.name;
	}

	public int getAge()
	{
		return this.age;
	}

	public int compareTo(Object obj)
	{
		// return 1;
		// return 0;
		return -1;
	}
}

class MyComparator implements Comparator
{
	public int compare(Object obj1, Object obj2)
	{
		Student s1 = (Student)obj1;
		Student s2 = (Student)obj2;

		int num = s1.getName().compareTo(s2.getName());

		if(num == 0)
		{
			return new Integer(s1.getAge()).compareTo(new Integer(s2.getAge()));
		}
		return num;
	}
}

class TreeSetDemoD
{
	public static void main(String[] args)
	{
		TreeSet ts = new TreeSet(new MyComparator());

		ts.add(new Student("lili021", 21));
		ts.add(new Student("lili021", 22));
		ts.add(new Student("lili022", 21));
		ts.add(new Student("lili023", 23));
		ts.add(new Student("lili022", 22));


		Iterator it = ts.iterator();

		while(it.hasNext())
		{
			Student s = (Student)it.next();

			System.out.println(s.getName()+"..||.."+s.getAge());
		}
	}
}
```

##### 3.3.2.5 TreeSet 练习（按字符串长度，字典序排序）

按字符串长度，字典序排列元素

(15/TreeSetTest)

```java
import java.util.*;

class TreeSetTestA
{
	public static void main(String[] args)
	{
		TreeSet ts = new TreeSet(new StrLenComparator());
		ts.add("ac");
		ts.add("bc");
		ts.add("abc");
		ts.add("addebc");
		ts.add("acd");
		ts.add("bdcd");
		ts.add("ebdcd");

		Iterator it = ts.iterator();

		while(it.hasNext())
		{
			System.out.println(it.next());
		}
	}
}

class StrLenComparator implements Comparator
{
	public int compare(Object obj1, Object obj2)
	{
		String s1 = (String)obj1;
		String s2 = (String)obj2;

		int num = new Integer(s1.length()).compareTo(new Integer(s2.length()));

		if(num == 0)
		{
			return s1.compareTo(s2);
		}

		return num;
	}
}
```

----------------------------

### 3.4 泛型

泛型： `JDK1.5` 版本以后出现的新特性。用于解决安全问题，是一个安全机制。

好处：

	1. 将运行时期出现的问题 ClassCastException，转移到了编译时期
		方便于程序员解决问题。让运行事情问题减少，安全。

	2. 避免了强制转换麻烦。

泛型格式：通过 `<>` 来定义要操作的引用数据类型。

在使用 `java` 提供的对象时，什么时候写泛型呢？

通常在集合框架中就很常见，只要见到 `<>` 就要定义泛型。

其实 `<>` 就是用来接受类型的。

当使用集合时，将集合中要存储的数据类型作为参数传递到 `<>` 中即可。

#### 3.4.1 泛型简介

**代码摘要**

	ArrayList<String> al = new ArrayList<String>();
	Iterator<String> it = al.iterator();

	class Student implements Comparable<Student>
	{
		public int compareTo(Student s)
		{

		}
	}

	class MyComparator implements Comparator<Student>
	{
		public int compare(Student s1, Student s2)
		{

		}
	}

(15/GenericDemoA)

```java
import java.util.*;

class GenericDemoA
{
	public static void main(String[] args)
	{
		ArrayList<String> al = new ArrayList<String>();

		al.add("java01");
		al.add("jav02");
		al.add("ja03");
		al.add("j04");
		al.add("java05");

		Iterator<String> it = al.iterator();

		while(it.hasNext())
		{
			String s = it.next();

			System.out.println(s+"::"+s.length());
		}
	}
}
```

(15/GenericDemoB)

```java
import java.util.*;

class Student implements Comparable<Student>
{
	private String name;
	private int age;

	Student(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public String getName()
	{
		return this.name;
	}
	public int getAge()
	{
		return this.age;
	}

	public int compareTo(Student s)
	{
		int num = new Integer(this.age).compareTo(new Integer(s.age));
		if(num == 0)
		{
			return this.name.compareTo(s.name);
		}
		return num;
	}
}

class MyComparator implements Comparator<Student>
{
	public int compare(Student s1, Student s2)
	{
		int num = new Integer(s2.getAge()).compareTo(new Integer(s1.getAge()));
		if(num == 0)
		{
			return s2.getName().compareTo(s1.getName());
		}
		return num;
	}
}

class GenericDemoB
{
	public static void main(String[] args)
	{
		TreeSet<Student> ts = new TreeSet<Student>();

		ts.add(new Student("aaa", 41));
		ts.add(new Student("aba", 42));
		ts.add(new Student("ama", 42));
		ts.add(new Student("caa", 43));
		ts.add(new Student("baa", 43));
		ts.add(new Student("aan", 43));
		ts.add(new Student("aaa", 44));

		Iterator<Student> it = ts.iterator();

		while(it.hasNext())
		{
			Student s = it.next();
			sop(s.getName() + "::|||::"+s.getAge());
		}

		sop("----------------------------");

		TreeSet<Student> ts2 = new TreeSet<Student>(new MyComparator());

		ts2.add(new Student("aaa", 41));
		ts2.add(new Student("aba", 42));
		ts2.add(new Student("ama", 42));
		ts2.add(new Student("caa", 43));
		ts2.add(new Student("baa", 43));
		ts2.add(new Student("aan", 43));
		ts2.add(new Student("aaa", 44));

		Iterator<Student> it2 = ts2.iterator();

		while(it2.hasNext())
		{
			Student s = it2.next();
			sop(s.getName() + "::|||::"+s.getAge());
		}
	}

	public static void sop(Object obj)
	{
		System.out.println(obj);
	}
}
```

----------------------------

#### 3.4.2 泛型类

什么时候定义泛型类？

	当类中要操作的引用数据类型不确定的时候，
	早期定义 *Object* 来完成扩展。
	现在定义泛型来完成扩展。

**注意：泛型里面定义的都是引用数据类型**

(15/GenericDemoC)

```java
import java.util.*;

class Student
{
	private String name;

	Student(String name)
	{
		this.name = name;
	}
	public String getName()
	{
		return this.name;
	}
}

class Worker
{
	private int age;

	Worker(int age)
	{
		this.age = age;
	}

	public int getAge()
	{
		return this.age;
	}
}

class Tool<TT>
{
	private TT g;

	public void setObject(TT g)
	{
		this.g = g;
	}

	public TT getObject()
	{
		return this.g;
	}
}

class GenericDemoC
{
	public static void main(String[] args)
	{
		Tool<Student> t1 = new Tool<Student>();
		t1.setObject(new Student("lili"));
		Student s1 = t1.getObject();
		System.out.println(s1.getName());	//lili

		Tool<Worker> t2 = new Tool<Worker>();
		t2.setObject(new Worker(43));
		Worker w1 = t2.getObject();
		System.out.println(w1.getAge());	//43
	}
}
```

#### 3.4.3 泛型方法

泛型类定义的泛型，在整个类中有效。如果被方法使用，
那么泛型类的对象明确要操作的具体类型后，所有要操作的类型就已经固定了。

为了在一个类中，让不同方法可以操作不同类型，而且类型不确定，
那么可以将泛型定义在方法上。

特殊之处：
静态方法不可以访问类上定义的泛型。
如果静态方法操作的数据类型不确定，应该将泛型定义在方法上。

(15/GenericDemoD)

```java
import java.util.*;

class Demo<T>
{

	private T t;
	public void setSome(T t)
	{
		this.t = t;
	}
	public T getSome()
	{
		return this.t;
	}

	public <Q> void show(Q q)
	{
		System.out.println(q);
	}

	public <W> void print(W w)
	{
		System.out.println(w);
	}

	public static <S> void sayHi(S s)
	{
		System.out.println(s);
	}

	// public static void sayHello(T t)
	// 无法从静态上下文中引用非静态类型变量 T
	// {
	// 	System.out.println(t);
	// }
}

class GenericDemoD
{
	public static void main(String[] args)
	{
		Demo<String> d = new Demo<String>();
		d.show(43);
		d.show("SSSS");
		d.print("WWWW");

		// d.setSome(444);		//Error：ClassCastException
		d.setSome("OOOO");
		System.out.println(d.getSome());	//"OOOO"

		Demo.sayHi("Hellowwwwwwww");	//Hellowwwwwwww
	}
}
```

----------------------------

#### 3.4.4 泛型接口

(15/GenericDemoE)

```java
import java.util.*;

interface Inter<T>
{
	public void show(T t);

	public <W> void print(W w);
}

class DemoA implements Inter<String>
{
	public void show(String t)
	{
		System.out.println(t);
	}

	public <W> void print(W w)
	{
		System.out.println(w);
	}
}

class DemoB<E> implements Inter<E>
{
	public void show(E e)
	{
		System.out.println(e);
	}

	public <W> void print(W w)
	{
		System.out.println(w);
	}
}

class GenericDemoE
{
	public static void main(String[] args)
	{
		DemoA d1 = new DemoA();
		// d1.show(333);	//classCastException
		d1.show("hhh");
		d1.print("fff");
		d1.print(321);

		DemoB<Integer> d2 = new DemoB<Integer>();
		// d2.show("aaa");	//classCastException
		d2.show(444);
		d2.print("EEE");
		d2.print(888);

	}
}
```

#### 3.4.5 泛型的泛型限定

`?` 通配符。也可以理解为占位符。
泛型的限定：
`? extends E` : 可以接收 `E类型` 或者 `E类的子类型`。上限。
`? super E` : 可以接收 `E类型` 或者 `E类的父类型`。下限。

(15/GenericDemoF)

```java
import java.util.*;

class Person
{
	private String name;
	private int age;

	Person(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public String getName()
	{
		return this.name;
	}

	public int getAge()
	{
		return this.age;
	}
}

class Student extends Person
{
	Student(String name, int age)
	{
		super(name, age);
	}
}

class Worker extends Person
{
	Worker(String name, int age)
	{
		super(name, age);
	}
}

class MyComparator implements Comparator<Person>
{
	public int compare(Person p1, Person p2)
	{
		return p1.getName().compareTo(p2.getName());
	}
}

class GenericDemoF
{
	public static void main(String[] args)
	{
		TreeSet<Student> tss = new TreeSet<Student>(new MyComparator());
		tss.add(new Student("ss1", 11));
		tss.add(new Student("ss3", 13));
		tss.add(new Student("ss2", 12));
		tss.add(new Student("ss5", 15));
		tss.add(new Student("ss4", 14));

		printColl(tss);



		TreeSet<Worker> tsw = new TreeSet<Worker>(new MyComparator());
		tsw.add(new Worker("ww1", 21));
		tsw.add(new Worker("ww5", 25));
		tsw.add(new Worker("ww3", 23));
		tsw.add(new Worker("ww4", 24));
		tsw.add(new Worker("ww2", 22));

		printColl(tsw);
	}

	public static void printColl(TreeSet<? extends Person> al)
	{
		Iterator<? extends Person> it = al.iterator();

		while(it.hasNext())
		{
			Person p = it.next();
			System.out.println(p.getName()+"--||--"+p.getAge());
		}
	}
}
```

----------------------------

### 4. 集合类 Map

	Map:
	  	|--- HashTable: （JDk 1.0，效率低）
	  			底层是 **哈希表** 数据结构，不可以存入 null 键 null 值。该集合时线程同步的。
	  	|--- HashMap:	（JDK 1.2，效率高）
	  			底层是 **哈希表** 数据结构，允许使用 null 键 和 null 值，该集合是不同步的。 
	  	|--- TreeMap:
	  		  	底层是 **二叉树** 数据结构。线程不同步。可以用于给 Map 集合中的键进行排序。

**Set底层就是使用Map集合。**


#### 4.1 集合类 Map的基本操作

1. 添加
	put(K key, V value)
	putAll(Map<? extends K, ? extends V> m)
2. 删除
	clear()
	remove(Object key)
3. 判断
	containsValue(Object value)
	containsKey(Object key)
	isEmpty()
4. 获取
	get(Object key)
	size()
	values()

----------------------------

#### 4.2 Map 的共性方法

(16/HashMapDemoA)

```java
import java.util.*;

class HashMapDemoA
{
	public static void main(String[] args)
	{
		Map<String, String> map = new HashMap<String, String>();
		map.put("01", "ZhangSan");
		map.put("02", "LiSi");
		map.put("03", "WangWu");
		map.put("04", "ZhaoLiu");

		System.out.println(map);	//{01=ZhangSan, 02=LiSi, 03=WangWu, 04=ZhaoLiu}

		// containsKey(K key)
		System.out.println(map.containsKey("01"));		//true

		System.out.println(map.containsKey("08"));		//false

		// containsKey(V value)
		System.out.println(map.containsValue("LiSi"));	//true
		
		System.out.println(map.containsValue("Heimi"));	//false

		// remove(K key)
		// 如果Map中存在该键，并且该键的值不为null，remove会返回该键对应的值
		System.out.println(map.remove("03"));	//WangWu

		System.out.println(map.remove("09"));	//null

		System.out.println(map);	//{01=ZhangSan, 02=LiSi, 04=ZhaoLiu}

		// get(K key)
		System.out.println(map.get("05"));		//null

		System.out.println(map.get("04"));		//ZhaoLiu

		// put(K key, V value)
		// 如果 map 中已存在该键，并且对应键值不为 null，
		// put会覆盖掉该键对应的值，并返回该键被覆盖的值。
		System.out.println(map.put("01", "Lili"));		//ZhangSan

		System.out.println(map.put("06", "Wuwu")); 		//null

		System.out.println(map.put(null, "Ulili"));		//null
		System.out.println(map.put("05", null));		//null


		System.out.println(map);
		//{null=Ulili, 01=Lili, 02=LiSi, 04=ZhaoLiu, 05=null, 06=Wuwu}

		// values()
		Collection<String> coll = map.values();

		System.out.println(coll);		//[Ulili, Lili, LiSi, ZhaoLiu, null, Wuwu]

		Iterator<String> it = coll.iterator();
		while(it.hasNext())
		{
			System.out.println(it.next());
			// Ulili
			// Lili
			// LiSi
			// ZhaoLiu
			// null
			// Wuwu
		}
	}
}
```

----------------------------

#### 4.3 Map KeySet() 和 entrySet()

map集合的两种取出方式：
	
* `Set<k> keySet` : 将 `map` 中的所有的键存入到 `Set` 集合。由于 `Set` 具备迭代器，所以可以迭代方式取出所有的键，再根据 `get` 方法，获取每一个键对应的值。
（`Map` 集合的取出原理：将 `map` 集合转成 `set` 集合。通过迭代器取出。）

* `Set<Map.Entry<k, v>> entrySet` : 将 `map` 集合中的映射关系存入到了 `set` 集合中，而这个关系的数据类型就是: `Map.Entry`

(16/KeySetDemoA)

```java
import java.util.*;

class KeySetDemoA
{
	public static void main(String[] args)
	{
		Map<String, String> map = new HashMap<String, String>();
		map.put("01", "ZS01");
		map.put("02", "ZS02");
		map.put("03", "ZS03");
		map.put("04", "ZS04");
		map.put("05", "ZS05");


		Set<String> keyset = map.keySet();
		System.out.println(keyset);		//[01, 02, 03, 04, 05]

		map.put("06", "ZS06");
		map.put("07", "ZS07");
		
		// Set 是引用类型
		System.out.println(keyset);		//[01, 02, 03, 04, 05, 06, 07]


		Iterator<String> it = keyset.iterator();
		while(it.hasNext())
		{
			String key = it.next();
			String value = map.get(key);
			System.out.println("key: "+key+", value: "+ value);
			// key: 01, value: ZS01
			// key: 02, value: ZS02
			// key: 03, value: ZS03
			// key: 04, value: ZS04
			// key: 05, value: ZS05
			// key: 06, value: ZS06
			// key: 07, value: ZS07
		}
	}
}
```

(16/EntrySetDemoA)

```java
import java.util.*;

class EntrySetDemoA
{
	public static void main(String[] args)
	{
		Map<String, String> map = new HashMap<String, String>();
		map.put("01", "ZS01");
		map.put("02", "ZS02");
		map.put("03", "ZS03");
		map.put("04", "ZS04");
		map.put("05", "ZS05");

		Set<Map.Entry<String, String>> entryset = map.entrySet();

		System.out.println(entryset);	//[01=ZS01, 02=ZS02, 03=ZS03, 04=ZS04, 05=ZS05]

		Iterator<Map.Entry<String, String>> it = entryset.iterator();

		while(it.hasNext())
		{
			Map.Entry<String, String> me = it.next();
			System.out.println("Key: "+me.getKey()+" Value: "+me.getValue());

			// Key: 01 Value: ZS01
			// Key: 02 Value: ZS02
			// Key: 03 Value: ZS03
			// Key: 04 Value: ZS04
			// Key: 05 Value: ZS05
		}

	}
}
```


#### 4.4 Map 练习

##### 4.4.1 学生--地址簿

当一个类可能有众多实例的时候，在存储的时候，有可能会存 `哈希表结构` 或者 `二叉树` 结构，所以在定义类时，要注意实现 `Comparable接口` 以及 覆盖 `hashCode()` 和 `equals(Object obj)` 方法。
**注意 `equals(Object obj)` 中的参数类型是 `Object` **

(16/MapTestDemoA)

```java
import java.util.*;

class Student implements Comparable<Student>
{
	private String name;
	private int age;

	Student(String name, int age)
	{
		this.name = name;
		this.age = age;
	}

	public String getName()
	{
		return this.name;
	}
	public int getAge()
	{
		return this.age;
	}

	public String getMessage()
	{
		return this.name +"..."+ this.age;
	}

	public int compareTo(Student s)
	{
		int num = new Integer(this.age).compareTo(new Integer(s.age));
		if(num == 0)
		{
			return this.name.compareTo(s.name);
		}
		else
		{
			return num;
		}
	}

	public int hashCode()
	{
		return this.name.hashCode() + this.age * 43;
	}

	// public boolean equals(Student s)			!!!!!!!
	// {
	// 	return this.name.equals(s.name) && this.age == s.age;
	// }
	
	public boolean equals(Object obj)
	{
		if(!(obj instanceof Student))
		{
			throw new ClassCastException("Obj is not the instance of Sutdent");
		}
		Student s = (Student)obj;

		return this.name.equals(s.name) && this.age == s.age;

	}
}


class MapDemoA
{
	public static void main(String[] args)
	{
		Map<Student, String> sts = new HashMap<Student, String>();

		sts.put(new Student("YY01", 11), "Beijin");
		sts.put(new Student("YY02", 12), "Shanghai");
		sts.put(new Student("YY02", 12), "Nanjing");
		sts.put(new Student("YY03", 13), "Tianjin");
		sts.put(new Student("YY04", 14), "Wuhan");
		sts.put(new Student("YY05", 15), "Guangzhou");

		// System.out.println(sts);
		
		Set<Student> keyset = sts.keySet();

		Iterator<Student> itk = keyset.iterator();
		while(itk.hasNext())
		{
			Student s = itk.next();
			System.out.println(s.getMessage() +"---"+sts.get(s));
		}

		System.out.println("---------------------------------------");

		Set<Map.Entry<Student, String>> entrySet = sts.entrySet();
		Iterator<Map.Entry<Student, String>> ite = entrySet.iterator();
		while(ite.hasNext())
		{
			Map.Entry<Student, String> e = ite.next();

			Student key = e.getKey();
			String addr = e.getValue();

			System.out.println(key.getMessage() +"||||"+ addr);
		}
	}
}
```

----------------------------

##### 4.4.2 将学生信息按给定顺序排序

(16/MapTestDemoB)

```java
import java.util.*;

class MyComparatorA implements Comparator<Student>
{
	public int compare(Student s1, Student s2)
	{
		int num = new Integer(s2.getAge()).compareTo(new Integer(s1.getAge()));
		if(num == 0)
		{
			return s2.getName().compareTo(s2.getName());
		}
		return num;
	}
}

class MyComparatorB implements Comparator<Student>
{
	public int compare(Student s1, Student s2)
	{
		int num = s1.getName().compareTo(s2.getName());
		if(num == 0)
		{
			return new Integer(s1.getAge()).compareTo(new Integer(s2.getAge()));
		}
		return num;
	}
}

class MapTestDemoB
{
	public static void main(String[] args)
	{
		TreeMap<Student, String> sts = new TreeMap<Student, String>();
		sts.put(new Student("YY01", 11), "Beijing");
		sts.put(new Student("YY04", 14), "Nanjing");
		sts.put(new Student("YY02", 12), "Tianjin");
		sts.put(new Student("YY05", 15), "Guangzhou");
		sts.put(new Student("YY03", 13), "Wuhan");

		printColl(sts, " ^---^ ");

		System.out.println("---------------------------------");

		TreeMap<Student, String> stsA = new TreeMap<Student, String>(new MyComparatorA());

		stsA.put(new Student("BB02", 12), "BBBB");
		stsA.put(new Student("CC03", 13), "CCCC");
		stsA.put(new Student("AA01", 11), "AAAA");
		stsA.put(new Student("EE05", 15), "EEEE");
		stsA.put(new Student("DD04", 14), "DDDD");

		printColl(stsA, " **----** ");

		System.out.println("---------------------------------");
		
		TreeMap<Student, String> stsB = new TreeMap<Student, String>(new MyComparatorB());

		stsB.put(new Student("BB02", 12), "BBBB");
		stsB.put(new Student("CC03", 13), "CCCC");
		stsB.put(new Student("AA01", 11), "AAAA");
		stsB.put(new Student("EE05", 15), "EEEE");
		stsB.put(new Student("DD04", 14), "DDDD");

		printColl(stsB, " **----** ");

	}

	public static void printColl(TreeMap<Student, String> sts, String sperator)
	{
		Set<Student> set = sts.keySet();

		Iterator<Student> it = set.iterator();

		while(it.hasNext())
		{
			Student s = it.next();

			System.out.println(s.getMessage() + sperator + sts.get(s));
		}
	}
}
```

----------------------------

##### 4.4.3 获取字符串中字母出现的次数

**注意：泛型里面定义的都是引用数据类型**
`TreeMap<Character, Integer> tm = new TreeMap<Character, Integer>();`

(16/MapTestDemoC)

```java
import java.util.*;

class MyComparator implements Comparator<Character>
{
	public int compare(Character c1, Character c2)
	{
		return c1.compareTo(c2);
	}
}

class MapTestDemoC
{
	public static void main(String[] args)
	{
		String str = "aaaaaaaESBBBBABBWB;;dsajflka";
		charCount(str);
	}
	public static void charCount(String  str)
	{
		char[] strArr = str.toCharArray();

		TreeMap<Character, Integer> tm = new TreeMap<Character, Integer>();

		for(int x = 0; x < strArr.length; x++)
		{
			if(!(strArr[x] >= 'a' && strArr[x] <= 'z' || strArr[x] >= 'A' && strArr[x] <= 'Z'))
			{
				continue;
			}

			// char key = strArr[x];
			// if(tm.containsKey(key))
			// {	
			// 	int count = tm.get(key).intValue();
			// 	tm.put(key, ++count);
			// }else{
			// 	tm.put(key, 1);
			// }
			
			Integer value = tm.get(strArr[x]);

			if(value == null)
			{
				tm.put(strArr[x], 1);
			}
			else
			{
				tm.put(strArr[x], ++value);
			}

		}

		Iterator<Map.Entry<Character, Integer>> it = tm.entrySet().iterator();

		while(it.hasNext())
		{
			Map.Entry<Character, Integer> m = it.next();

			System.out.println(m.getKey() + " : " + m.getValue());
		}
	}
}
```

##### 4.4.4 Map 扩展(集合对象嵌套)

(16/MapDemoA)

```java
import java.util.*;

class Student
{
	private String id;
	private String name;

	Student(String id, String name)
	{
		this.name = name;
		this.id = id;
	}
	
	public String getMessage()
	{
		return this.id + " | " + this.name;
	}
}


class MapDemoA
{
	public static void main(String[] args)
	{
		HashMap<String, List<Student>> czbk1 = new HashMap<String, List<Student>>();

		List<Student> yure = new ArrayList<Student>();
		List<Student> jiuye = new ArrayList<Student>();

		yure.add(new Student("01", "zhangsan"));
		yure.add(new Student("02", "lisi"));
		yure.add(new Student("03", "wangwu"));
		jiuye.add(new Student("01", "zhaoliu"));
		jiuye.add(new Student("02", "sunqi"));
		jiuye.add(new Student("03", "chenba"));

		czbk1.put("yure", yure);
		czbk1.put("jiuye", jiuye);

		Iterator<String> it1 = czbk1.keySet().iterator();
		while(it1.hasNext())
		{
			String roomName = it1.next();
			System.out.println(roomName);

			Iterator<Student> itTemp = czbk1.get(roomName).iterator();
			while(itTemp.hasNext())
			{
				System.out.println(itTemp.next().getMessage());
			}

			System.out.println("---------------------------------");
		}




		HashMap<String, HashMap<String, String>> czbk2 = new HashMap<String, HashMap<String, String>>();

		HashMap<String, String> yure2 = new HashMap<String, String>();
		HashMap<String, String> jiuye2 = new HashMap<String, String>();
		yure2.put("001", "liliu");
		yure2.put("002", "songqi");
		yure2.put("003", "huangba");
		jiuye2.put("001", "zhujiu");
		jiuye2.put("002", "xushi");
		jiuye2.put("003", "chengsan");

		czbk2.put("yure2", yure2);
		czbk2.put("jiuye2", jiuye2);

		Iterator<String> it2 = czbk2.keySet().iterator();
		while(it2.hasNext())
		{
			String roomName = it2.next();
			HashMap<String, String> room = czbk2.get(roomName);
			System.out.println(roomName);
			System.out.println(room.keySet());

			Iterator<String> itTemp = room.keySet().iterator();
			while(itTemp.hasNext())
			{
				String id = itTemp.next();
				System.out.println(id + " : " + room.get(id));
			}

			System.out.println("---------------------------------------");
		}
	}
}
```

----------------------------

##### 4.4.5 Collections 集合框架的工具类

###### 4.4.5.1 sort()

(17/CollectionsSortDemoA)

```java
import java.util.*;

class CollectionsDemoA
{
	public static void main(String[] args)
	{
		sortDemo();
	}
	public static void sortDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("eedcuuud");
		list.add("abcd");
		list.add("ooadppp");
		list.add("ffacdi");
		list.add("qqwbdcd");
		list.add("wqwbdcd");

		sop(list);

		Collections.sort(list, new StrLenComparator());

		sop(list);
	}
	public static void sop(Object obj)
	{
		System.out.println(obj);
	}

	static class StrLenComparator implements Comparator<String>
	{
		public int compare(String s1, String s2)
		{
			int num = s1.length() - s2.length();

			if(num == 0)
			{
				return s1.compareTo(s2);
			}else{
				return num;
			}
		}
	}
}
```

###### 4.4.5.2 max()

(17/CollectionsMaxDemoA)

```java
import java.util.*;

class CollectionsMaxDemoA
{
	public static void main(String[] args)
	{
		maxDemo();
	}
	public static void maxDemo()
	{
		List<String> list = new ArrayList<String>();
		list.add("zzueiopwq");
		list.add("erwuioeiop");
		list.add("euyiorew");
		list.add("coooooovjklxfdkjl");
		list.add("rrueiopwq");
		list.add("eruiowds");

		Log.println(list);

		Log.println(Collections.max(list));

		Log.println(Collections.max(list, new StrLenComparator()));

	}

	static class StrLenComparator implements Comparator<String>
	{
		public int compare(String s1, String s2)
		{
			int num = s1.length()  - s2.length();
			if(num == 0)
			{
				return s1.compareTo(s2);
			}else
			{
				return num;
			}
		}
	}
}
```

###### 4.4.5.3 binarySearch()

如果搜索键包含在列表中，则返回搜索键的索引；
否则返回 (-(插入点) - 1)。
`插入点` 被定义为将键插入列表的那一点：即第一个大于此键的元素索引；
如果列表中的所有元素都小于指定的键，则为 list.size()。
注意，这保证了当且仅当此键被找到时，返回的值将 >= 0。

**注意：** 如果所查询的 `list` 经过自定义的排序(非默认自然排序)，则在调用 `binarySearch()` 方法时，也要将比较器传入。

(17/CollectionsBinarySearchDemoA)

```java
import java.util.*;

class CollectionsBinarySearchDemoA
{
	public static void main(String[] args)
	{
		binarySearchDemo();
	}
	public static void binarySearchDemo()
	{
		List<String> list = new ArrayList<String>();

		list.add("dd");
		list.add("bbb");
		list.add("cccd");
		list.add("a");
		list.add("eee");
		list.add("eeefff");


		Collections.sort(list, new StrLenComparator());
		Log.println(list);
		Log.println("eee1: " + Collections.binarySearch(list, "eee"));		// -6

		Log.println("eee2: " + Collections.binarySearch(list, "eee", new StrLenComparator()));		//3
		Log.println(Collections.binarySearch(list, "ddddddddddddddd", new StrLenComparator()));		// -6

		Log.println(halfSearch(list, "eee", new StrLenComparator())); //3

	}

	public static int halfSearch(List<String> list, String key, Comparator<String> cmp)
	{
		int max, min, mid;
		max = list.size() - 1;
		min = 0;

		while(min <= max)
		{
			mid = (max + min) >> 1;
			String str = list.get(mid);

			int num = cmp.compare(str, key);
			if(num > 0)
			{
				max = mid - 1;
			}else if(num < 0)
			{
				min = mid + 1;
			}else
			{
				return mid;
			}
		}
		return -min-1;

	}

	static class StrLenComparator implements Comparator<String>
	{
		public int compare(String s1, String s2)
		{
			int num = s1.length() - s2.length();
			if(num == 0)
			{
				return s1.compareTo(s2);
			}else
			{
				return num;
			}
		}
	}
}
```

###### 4.4.5.4 fill()

(17/CollectionsFillDemoA)

```java
import java.util.*;

class CollectionsFillDemoA
{
	public static void main(String[] args)
	{
		fillDemoA();
		Log.println("----------------------------------");

		fillDemoB();

	}
	public static void fillDemoA()
	{
		List<String> list = new ArrayList<String>();
		list.add("fdsjka");
		list.add("reuiwre");
		list.add("oupiiou");
		list.add("jklsad");
		list.add("mvnc");

		Log.println(list);

		Collections.fill(list, "ddes");

		Log.println(list);
	}

	public static void fillDemoB()
	{
		List<String> list = new ArrayList<String>();
		list.add("eeeeii");
		list.add("ffffee");
		list.add("wwwwrr");
		list.add("ppppcc");
		list.add("qqqqzz");
		list.add("iiiioo");
		list.add("mmmmll");

		Log.println(list);

		fillMethod(list, 3, 6, "AAAAA");

		Log.println(list);
	}

	public static void fillMethod(List<String> list, int startIndex, int endIndex, String key)
	{
		for(int x = startIndex; x < endIndex; x++)
		{
			list.set(x, key);
		}
	}
}
```

###### 4.4.5.5 replaceAll()

(17/CollectionsReplaceAllDemoA)

```java
import java.util.*;

class CollectionsReplaceAllDemoA
{
	public static void main(String[] args)
	{
		replaceAllDemoA();
		Log.println("----------------------------------");


	}
	public static void replaceAllDemoA()
	{
		List<String> list = new ArrayList<String>();
		list.add("fdsjka");
		list.add("mvnc");
		list.add("reuiwre");
		list.add("mvnc");
		list.add("oupiiou");
		list.add("jklsad");
		list.add("mvnc");

		Log.println(list);
		//[fdsjka, mvnc, reuiwre, mvnc, oupiiou, jklsad, mvnc]

		Collections.replaceAll(list, "mvnc", "AAAAA");

		Log.println(list);
		// [fdsjka, AAAAA, reuiwre, AAAAA, oupiiou, jklsad, AAAAA]
	}
}
```

###### 4.4.5.6 reverse()

(17/CollectionsReverseDemoA)

```java
import java.util.*;

class CollectionsReverseDemoA
{
	public static void main(String[] args)
	{
		reverseDemoA();
		Log.println("----------------------------------");


	}
	public static void reverseDemoA()
	{
		List<String> list = new ArrayList<String>();
		list.add("AAA");
		list.add("BBB");
		list.add("CCC");
		list.add("DDD");
		list.add("EEE");
		list.add("fff");
		list.add("gggg");

		Log.println(list);
		// [AAA, BBB, CCC, DDD, EEE, fff, gggg]

		Collections.reverse(list);

		Log.println(list);
		// [gggg, fff, EEE, DDD, CCC, BBB, AAA]
	}
}
```

###### 4.4.5.7 reverseOrder()

(17/CollectionsReverseOrderDemoA)

```java
 import java.util.*;

class CollectionsReverseOrderDemoA
{
	public static void main(String[] args)
	{
		reverseOrder();
	}
	public static void reverseOrder()
	{
		TreeSet<String> ts = new TreeSet<String>(new StrLenComparator());

		ts.add("fffff");
		ts.add("bbbb");
		ts.add("ddd");
		ts.add("cc");
		ts.add("e");

		Log.println(ts);
		// [e, cc, ddd, bbbb, fffff]
		


		
		TreeSet<String> ts1 = new TreeSet<String>(Collections.reverseOrder(new StrLenComparator()));

		ts1.add("fffff");
		ts1.add("bbbb");
		ts1.add("ddd");
		ts1.add("cc");
		ts1.add("e"); 

		Log.println(ts1);
		// [fffff, bbbb, ddd, cc, e]
		


		TreeSet<String> ts2 = new TreeSet<String>();

		ts2.add("fffff");
		ts2.add("bbbb");
		ts2.add("ddd");
		ts2.add("cc");
		ts2.add("e");

		Log.println(ts2);
		// [bbbb, cc, ddd, e, fffff]
		

		TreeSet<String> ts3 = new TreeSet<String>(Collections.reverseOrder());

		ts3.add("fffff");
		ts3.add("bbbb");
		ts3.add("ddd");
		ts3.add("cc");
		ts3.add("e");

		Log.println(ts3);
		//[fffff, e, ddd, cc, bbbb]
	}

	static class StrLenComparator implements Comparator<String>
	{
		public int compare(String s1, String s2)
		{
			int num = s1.length() - s2.length();
			if(num == 0)
			{
				return s1.compareTo(s2);
			}else
			{
				return num;
			}
		}
	}
}
```

###### 4.4.5.8 syncList()

(17/CollectionsSynListDemoA)

```java

```

###### 4.4.5.9 swap()


###### 4.4.5.10 shuff()

使用默认随机源对指定列表进行置换。

----------------------------

##### 4.4.6 Arrays 工具类

* toString();
* asList();

数组转集合后，可以用操作集合的方法对数组进行操作，但需要注意的是，数组转成的集合，只能 **改(Update)** 和 **查(Retrieve)**，不能 **增(Create)** 和 **删(Delete)**。
因为原数组的长度是固定的，如果 **增** 和 **删** ，会发生 `UnsupportedOperationException`.

**注意：** 使用 `asList()` 方法时：
如果数组中的元素都是 **对象** ，那么变成集合时，**数组中的元素** 就直接转成集合中的元素。
如果数组中的元素都是 **基本数据类型** ，那么会将 **该数组** 作为集合中的元素存在。

(17/ArraysDemoA)

```java
import java.util.*;

class ArraysDemoA
{
	public static void main(String[] args)
	{
		int[] arr0 = {2, 3, 4, 5};

		Log.println(arr0);		// [I@2a139a55

		String arr0Str = Arrays.toString(arr0);
		Log.println(arr0Str);	//[2, 3, 4, 5]




		String[] arr1 = {"aaa", "bbb", "CCC", "DDD", "eee"};

		List<String> arr1List = Arrays.asList(arr1);

		Log.println(arr1List.contains("aaa"));	//true

		// arr1List.add("qqqq"); // UnsupportedOperationException

		// arr1List.set(7, "ddddddd");		//ArrayIndexOutOfBoundsException
		
		arr1List.set(3, "ddddddd");

		Log.println(arr1List);		//[aaa, bbb, CCC, ddddddd, eee]




		int[] arr2 = {22, 333, 111, 4444, 555};

		List<int[]> arr2List = Arrays.asList(arr2);

		Log.println(arr2List);	//[[I@15db9742]


		Integer[] arr3 = {22, 333, 111, 4444, 555};

		List<Integer> arr3List = Arrays.asList(arr3);

		Log.println(arr3List);	//[22, 333, 111, 4444, 555]

	}
}
```

----------------------------

##### 4.4.7 集合转成数组

1. 指定类型的数组到底要定义多长呢？

当指定类型的数组长度小于集合的 `size`，那么该方法内部会创建一个新的数组，长度为 `集合的size`。
当指定类型的数组长度大于了集合的 `size`，就不会创建新数组，而是直接使用传递进来的数组。
所以创建一个长度刚刚好的数组最优。

2. 为什么要将集合变成数组？
为了限定对元素的操作，不能进行 **增** ， **删** 了。

(17/CollectionToArrayDemoA)

```java
import java.util.*;

class CollectionToArrayDemoA
{
	public static void main(String[] args)
	{
		ArrayList<String> list = new ArrayList<String>();

		list.add("aaa1");
		list.add("aaa2");
		list.add("aaa3");
		list.add("aaa4");

		Log.println(list);
		// [aaa1, aaa2, aaa3, aaa4]
		

		String[] arr = list.toArray(new String[list.size()]);
		Log.println(arr);
		// [Ljava.lang.String;@2a139a55
		
		Log.println(Arrays.toString(arr));
		// [aaa1, aaa2, aaa3, aaa4]
		 
		Log.println(Arrays.asList(arr));
		// [aaa1, aaa2, aaa3, aaa4]
		



		String[] arr1 = list.toArray(new String[9]);

		Log.println(arr1);
		// [Ljava.lang.String;@15db9742
		
		Log.println(Arrays.toString(arr1));
		// [aaa1, aaa2, aaa3, aaa4, null, null, null, null, null]

		Log.println(Arrays.asList(arr1));
		// [aaa1, aaa2, aaa3, aaa4, null, null, null, null, null]
	}
}
```

##### 4.4.8 高级 for 循环 

**高级for循环** 格式：

	for(数据类型 变量名 : 被遍历的集合或者数组)
	{

	}


对集合进行遍历。只能获取集合元素。但是不能对集合进行操作。

`迭代器(Iterator)` 除了遍历，还可以进行 `remove` 集合中的元素。
如果是 `ListIterator` ，还可以在遍历过程中对集合进行 **增删改查** 等动作。

**传统for循环** 和 **高级for循环** 有什么区别呢？
**高级for循环** 有一个局限性，必须有被遍历的目标。

建议在遍历数组的时候，采用 **传统for循环** ，因为可以定义脚标。


(17/ForDemoA)

```java
import java.util.*;

class ForEachDemoA
{
	public static void main(String[] args)
	{
		ArrayList<String> al = new ArrayList<String>();

		al.add("aaa1");
		al.add("aaa2");
		al.add("aaa3");
		al.add("aaa4");

		for(String s : al)
		{
			Log.println(s);
		}

		ListIterator<String> lIt = al.listIterator();
		while(lIt.hasNext())
		{
			Log.println("lIt : " + lIt.next());
			lIt.set("bbbB");
		}
		Log.println(al);	//[bbbB, bbbB, bbbB, bbbB]



		Iterator<String> it = al.iterator();
		while(it.hasNext())
		{
			Log.println("it : " + it.next());
			it.remove();
		}
		Log.println(al);	//[]




		HashMap<Integer, String> hm = new HashMap<Integer, String>();
		hm.put(1, "a");
		hm.put(2, "b");
		hm.put(3, "c");
		hm.put(4, "d");

		Set<Integer> keySet = hm.keySet();

		for(Integer i : keySet)
		{
			Log.println(i + "::::" +hm.get(i));
		}


		for(Integer i : hm.keySet())
		{
			Log.println(i + ":" +hm.get(i));
		}


		Set<Map.Entry<Integer, String>> me = hm.entrySet();
		for(Map.Entry<Integer, String> m : me)
		{
			Log.println(m.getKey() +" --------- "+m.getValue());
		}

		for(Map.Entry<Integer, String> mm : hm.entrySet())
		{
			Log.println(mm.getKey() + ":::::::::" + mm.getValue());
		}
	}
}
```

##### 4.4.9  可变参数(`...`)

(17/ParamMethodDemoA)

```java
import java.util.*;

class ParamMethodDemoA
{
	public static void main(String[] args)
	{
		show("AAA", 11, 22, 33, 44, 55);
		// 5
		// [11, 22, 33, 44, 55]


		show("BBB", 888, 777, 666, 555, 4, 3, 2, 1, 33);
		// 9
		// [888, 777, 666, 555, 4, 3, 2, 1, 33]
	}

	public static void show(String s, int... arr)
	{
		Log.println(arr.length);
		Log.println(Arrays.toString(arr));
	}
}
```

##### 4.4.10  静态导入

`StaticImport` 静态导入。

当 **类名重名** 时，需要指定具体的包名。
当 **方法重名** 时，指定所属的对象或类。

(17/StaticImportDemoA)
 
```java
import java.util.*;

import static java.util.Arrays.*;

class StaticImportDemoA
{
	public static void main(String[] args)
	{
		int[] arr = {43, 11, 22};

		sort(arr);

		Log.println(Arrays.toString(arr)); // [11, 22, 43]
		
		Log.println(binarySearch(arr, 22)); // 1
	}
}
```

----------------------------

### 5. 其他对象

#### 5.1 System 对象

在 System 类提供的设施中，有标准输入、标准输出和错误输出流；对外部定义的属性和环境变量的访问；加载文件和库的方法；还有快速复制数组的一部分的实用方法。

`System` 类中的方法和属性都是 **静态** 的。
`out` : 标准输出，默认是控制台。
`in` : 标准输入，默认是键盘。


在jvm启动时，动态加载一些属性信息

	java -Dhaha=qqqqqqq SystemDemo


`Properties` 是 `HashTable` 的子类，也就是 `Map` 集合的一个子类对象。

(18/SystemDemoA)

```java
import java.util.*; 

class SystemDemoA
{
	public static void main(String[] args)
	{
		Properties props = System.getProperties();

		for(Object key : props.keySet())
		{
			Object value = (String)props.get(key);

			Log.println(key + " :-----: " + value);
		}



		System.setProperty("myKey", "myValueeeeeeeeee");

		String myValue = System.getProperty("myKey");
		Log.println("myValue : " + myValue);

		Log.println("v :" + System.getProperty("v"));
	}
}
```

#### 5.2 Runtime 对象

`Runtime` 对象
该类并没有提供构造函数。
说明该类不可以 `new` 对象。那么会直接想到该类中的方法都是 **静态** 的。
发现该类中还有 **非静态** 方法。
说明该类肯定会提供方法获取本类对象。而且该方法是 **静态** 的，并返回值是本类类型。
有这个特点可以看出该类使用了 **单例设计模式** 完成。

(18/RuntimeDemoA)

```java
class RuntimeDemoA
{
	public static void main(String[] args) throws Exception
	{
		Runtime r = Runtime.getRuntime();
		Process p1 = r.exec("notepad.exe RuntimeDemoA.java");

		Thread.sleep(4000);
		p1.destroy();
	}
}
```

#### 5.3 Date 对象

(18/DateDemoA)

```java
import java.util.*;
import java.text.*;

class DateDemoA
{
	public static void main(String[] args)
	{
		Date d = new Date();
		Log.println(d);

		SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

		String time = sdf.format(d);

		Log.println(time);

	}
}
```

#### 5.4 Calendar 对象

(18/CalendarDemo)

```java
import java.util.*;
import java.text.*;

class CalendarDemoA
{
	public static void main(String[] args)
	{
		getTime();

		Log.println("---------------------------------------");

		setTime();

		Log.println("---------------------------------------");

		addTime();

		Log.println("---------------------------------------");

		otherMethod();
	}

	public static void getTime()
	{
		Calendar rightNow = Calendar.getInstance();

		Log.println(rightNow);

		Log.println("YEAR: " + rightNow.get(Calendar.YEAR));
		Log.println("MONTH: " + rightNow.get(Calendar.MONTH));
		Log.println("DAY_OF_MONTH: " + rightNow.get(Calendar.DAY_OF_MONTH));
		Log.println("DAY_OF_WEEK: " + rightNow.get(Calendar.DAY_OF_WEEK));
		Log.println("DAY_OF_WEEK_IN_MONTH: " + rightNow.get(Calendar.DAY_OF_WEEK_IN_MONTH));
		Log.println("WEEK_OF_MONTH : " + rightNow.get(Calendar.WEEK_OF_MONTH ));
		Log.println("DAY_OF_YEAR: " + rightNow.get(Calendar.DAY_OF_YEAR));
		Log.println("HOUR: " + rightNow.get(Calendar.HOUR));
		Log.println("MINUTE: " + rightNow.get(Calendar.MINUTE));
		Log.println("SECOND: " + rightNow.get(Calendar.SECOND));
	}

	public static void setTime()
	{
		Calendar rightNow = Calendar.getInstance();
		rightNow.set(2021, 1, 30);	
		Log.println(rightNow);

		Log.println("YEAR: " + rightNow.get(Calendar.YEAR)); 	//2021
		Log.println("MONTH: " + rightNow.get(Calendar.MONTH));	// 02
		Log.println("DAY_OF_MONTH: " + rightNow.get(Calendar.DAY_OF_MONTH));	//02
	}

	public static void addTime()
	{
		Calendar rightNow = Calendar.getInstance();
		rightNow.set(2035, 0, 22);
		Log.println("YEAR0: " + rightNow. get(Calendar.YEAR));

		rightNow.add(Calendar.YEAR, 18);
		Log.println("YEAR1: " + rightNow.get(Calendar.YEAR));

		rightNow.add(Calendar.YEAR, -28);
		Log.println("YEAR1: " + rightNow.get(Calendar.YEAR));
	}

	public static void otherMethod()
	{
		Calendar rightNow = Calendar.getInstance();

		Log.println(rightNow.getFirstDayOfWeek());
	}
}
```

#### 5.5 Math-Random 对象

(18/MathRandomDemoA)

```java
import java.util.Random;

class MathRandomDemoA
{
	public static void main(String[] args)
	{
		method0();

		Log.println("------------------------------");

		method1();

		Log.println("------------------------------");

		method2();
	}

	public static void method0()
	{
		double n1 = Math.ceil(13.43);
		Log.println("n1: " + n1);

		double n2 = Math.floor(11.43);
		Log.println("n2: " + n2);

		double n3 = Math.round(13.43);
		Log.println("n3: " + n3);

		double n4 = Math.pow(4, 5);
		Log.println("n4: " + n4);
	}

	public static void method1()
	{
		Random r = new Random();
		for(int x = 0; x < 10; x++)
		{
			Log.println(r.nextInt(10));
		}
		Log.println("---------");
		for(int x = 0; x < 10; x++)
		{
			Log.println(r.nextFloat());
		}
	}

	public static void method2()
	{
		for(int x = 0; x < 10; x++)
		{
			double d = Math.random();
			Log.println(d);
		}
	}
}
```